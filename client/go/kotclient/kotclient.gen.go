// Package kotclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package kotclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for DailyWorkingResponseAutoBreakOff.
const (
	DailyWorkingResponseAutoBreakOffN1 DailyWorkingResponseAutoBreakOff = 1
	DailyWorkingResponseAutoBreakOffN2 DailyWorkingResponseAutoBreakOff = 2
	DailyWorkingResponseAutoBreakOffN3 DailyWorkingResponseAutoBreakOff = 3
)

// Defines values for DailyWorkingResponseCurrentDateEmployeeGender.
const (
	Female     DailyWorkingResponseCurrentDateEmployeeGender = "female"
	Male       DailyWorkingResponseCurrentDateEmployeeGender = "male"
	NoSelected DailyWorkingResponseCurrentDateEmployeeGender = "no_selected"
)

// Defines values for DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode.
const (
	DailyWorkingResponseCustomDailyWorkingsCalculationUnitCodeN1 DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode = 1
	DailyWorkingResponseCustomDailyWorkingsCalculationUnitCodeN2 DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode = 2
	DailyWorkingResponseCustomDailyWorkingsCalculationUnitCodeN4 DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode = 4
)

// Defines values for DailyWorkingTimerecordCode.
const (
	DailyWorkingTimerecordCodeN1 DailyWorkingTimerecordCode = "1"
	DailyWorkingTimerecordCodeN2 DailyWorkingTimerecordCode = "2"
	DailyWorkingTimerecordCodeN3 DailyWorkingTimerecordCode = "3"
	DailyWorkingTimerecordCodeN4 DailyWorkingTimerecordCode = "4"
	DailyWorkingTimerecordCodeN7 DailyWorkingTimerecordCode = "7"
	DailyWorkingTimerecordCodeN8 DailyWorkingTimerecordCode = "8"
)

// Defines values for DailyWorkingTimerecordRequestCode.
const (
	DailyWorkingTimerecordRequestCodeN1 DailyWorkingTimerecordRequestCode = "1"
	DailyWorkingTimerecordRequestCodeN2 DailyWorkingTimerecordRequestCode = "2"
	DailyWorkingTimerecordRequestCodeN3 DailyWorkingTimerecordRequestCode = "3"
	DailyWorkingTimerecordRequestCodeN4 DailyWorkingTimerecordRequestCode = "4"
	DailyWorkingTimerecordRequestCodeN7 DailyWorkingTimerecordRequestCode = "7"
	DailyWorkingTimerecordRequestCodeN8 DailyWorkingTimerecordRequestCode = "8"
)

// Defines values for GetAdministratorsParamsAdditionalFields.
const (
	GetAdministratorsParamsAdditionalFieldsAssociatedEmployees GetAdministratorsParamsAdditionalFields = "associatedEmployees"
	GetAdministratorsParamsAdditionalFieldsEmailAddresses      GetAdministratorsParamsAdditionalFields = "emailAddresses"
)

// Defines values for GetDailyWorkingsParamsAdditionalFields.
const (
	GetDailyWorkingsParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingsParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingTimerecordsParamsAdditionalFields.
const (
	GetDailyWorkingTimerecordsParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingTimerecordsParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingTimerecordParamsAdditionalFields.
const (
	GetDailyWorkingTimerecordParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingTimerecordParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingParamsAdditionalFields.
const (
	GetDailyWorkingParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetEmployeeGroupsParamsAdditionalFields.
const (
	Category GetEmployeeGroupsParamsAdditionalFields = "category"
)

// Defines values for GetEmployeesParamsAdditionalFields.
const (
	GetEmployeesParamsAdditionalFieldsAllDayRegardingWorkInMinute GetEmployeesParamsAdditionalFields = "allDayRegardingWorkInMinute"
	GetEmployeesParamsAdditionalFieldsBirthDate                   GetEmployeesParamsAdditionalFields = "birthDate"
	GetEmployeesParamsAdditionalFieldsEmailAddresses              GetEmployeesParamsAdditionalFields = "emailAddresses"
	GetEmployeesParamsAdditionalFieldsFirstNamePhonetics          GetEmployeesParamsAdditionalFields = "firstNamePhonetics"
	GetEmployeesParamsAdditionalFieldsHiredDate                   GetEmployeesParamsAdditionalFields = "hiredDate"
	GetEmployeesParamsAdditionalFieldsLastNamePhonetics           GetEmployeesParamsAdditionalFields = "lastNamePhonetics"
	GetEmployeesParamsAdditionalFieldsResignationDate             GetEmployeesParamsAdditionalFields = "resignationDate"
)

// Defines values for GetEmployeeParamsAdditionalFields.
const (
	AllDayRegardingWorkInMinute GetEmployeeParamsAdditionalFields = "allDayRegardingWorkInMinute"
	BirthDate                   GetEmployeeParamsAdditionalFields = "birthDate"
	EmailAddresses              GetEmployeeParamsAdditionalFields = "emailAddresses"
	FirstNamePhonetics          GetEmployeeParamsAdditionalFields = "firstNamePhonetics"
	HiredDate                   GetEmployeeParamsAdditionalFields = "hiredDate"
	LastNamePhonetics           GetEmployeeParamsAdditionalFields = "lastNamePhonetics"
	ResignationDate             GetEmployeeParamsAdditionalFields = "resignationDate"
)

// Defines values for GetOvertimesParamsAdditionalFields.
const (
	GetOvertimesParamsAdditionalFieldsFlow                GetOvertimesParamsAdditionalFields = "flow"
	GetOvertimesParamsAdditionalFieldsNote                GetOvertimesParamsAdditionalFields = "note"
	GetOvertimesParamsAdditionalFieldsSchedulePatternCode GetOvertimesParamsAdditionalFields = "schedulePatternCode"
	GetOvertimesParamsAdditionalFieldsSchedulePatternName GetOvertimesParamsAdditionalFields = "schedulePatternName"
	GetOvertimesParamsAdditionalFieldsWorkFixedEnd        GetOvertimesParamsAdditionalFields = "workFixedEnd"
	GetOvertimesParamsAdditionalFieldsWorkFixedStart      GetOvertimesParamsAdditionalFields = "workFixedStart"
)

// Defines values for GetSchedulesParamsAdditionalFields.
const (
	GetSchedulesParamsAdditionalFieldsFlow                GetSchedulesParamsAdditionalFields = "flow"
	GetSchedulesParamsAdditionalFieldsNote                GetSchedulesParamsAdditionalFields = "note"
	GetSchedulesParamsAdditionalFieldsSchedulePatternCode GetSchedulesParamsAdditionalFields = "schedulePatternCode"
	GetSchedulesParamsAdditionalFieldsSchedulePatternName GetSchedulesParamsAdditionalFields = "schedulePatternName"
	GetSchedulesParamsAdditionalFieldsWorkFixedEnd        GetSchedulesParamsAdditionalFields = "workFixedEnd"
	GetSchedulesParamsAdditionalFieldsWorkFixedStart      GetSchedulesParamsAdditionalFields = "workFixedStart"
)

// DailyWorkingResponse defines model for daily_working_response.
type DailyWorkingResponse struct {
	// Assigned 所定時間（分）
	Assigned int `json:"assigned"`

	// AutoBreakOff 自動休憩無効（null： 休憩を無効化しない 1：　雇用区分休憩無効　2： スケジュール休憩無効　3： 全ての自動休憩無効）
	AutoBreakOff DailyWorkingResponseAutoBreakOff `json:"autoBreakOff"`

	// BreakTime 休憩時間（分）
	BreakTime int `json:"breakTime"`

	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *struct {
		// Code 従業員コード
		Code string `json:"code"`

		// DivisionCode 所属コード
		DivisionCode string `json:"divisionCode"`

		// DivisionName 所属名
		DivisionName string `json:"divisionName"`

		// EmployeeGroups 従業員グループ情報
		EmployeeGroups []struct {
			// Code 従業員グループコード
			Code string `json:"code"`

			// Name 従業員グループ名
			Name string `json:"name"`
		} `json:"employeeGroups"`

		// FirstName 名
		FirstName string `json:"firstName"`

		// FirstNamePhonetics 名（カナ）
		FirstNamePhonetics string `json:"firstNamePhonetics"`

		// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
		Gender DailyWorkingResponseCurrentDateEmployeeGender `json:"gender"`

		// LastName 姓
		LastName string `json:"lastName"`

		// LastNamePhonetics 姓（カナ）
		LastNamePhonetics string `json:"lastNamePhonetics"`

		// TypeCode 雇用区分コード
		TypeCode string `json:"typeCode"`

		// TypeName 雇用区分名
		TypeName string `json:"typeName"`
	} `json:"currentDateEmployee,omitempty"`
	CustomDailyWorkings struct {
		// CalculationResult 計算結果
		CalculationResult int `json:"calculationResult"`

		// CalculationUnitCode 計算単位コード（1： 日数　2： 時間　4： 数値）
		CalculationUnitCode DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode `json:"calculationUnitCode"`

		// Code 日別カスタム表示コード
		Code string `json:"code"`

		// Name 日別カスタム表示名
		Name string `json:"name"`
	} `json:"customDailyWorkings"`

	// Date 日時
	Date openapi_types.Date `json:"date"`

	// DiscretionaryVacation 休暇みなし時間（分）
	DiscretionaryVacation int `json:"discretionaryVacation"`

	// EarlyLeave 早退時間（分）
	EarlyLeave int `json:"earlyLeave"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// HolidaysObtained 休暇取得
	HolidaysObtained struct {
		FulltimeHoliday struct {
			// Code 休暇区分コード
			Code int `json:"code"`

			// Name 休暇区分名
			Name string `json:"name"`
		} `json:"fulltimeHoliday"`
		HalfdayHolidays struct {
			// Code 休暇区分コード
			Code int `json:"code"`

			// Name 休暇区分名
			Name string `json:"name"`

			// TypeName 半休種別名
			TypeName string `json:"typeName"`
		} `json:"halfdayHolidays"`
		HourHolidays struct {
			// Code 休暇区分コード
			Code int `json:"code"`

			// End 休暇終了時間
			End time.Time `json:"end"`

			// Minutes 休暇取得時間
			Minutes int `json:"minutes"`

			// Name 休暇区分名
			Name string `json:"name"`

			// Start 休暇開始時間
			Start time.Time `json:"start"`
		} `json:"hourHolidays"`
	} `json:"holidaysObtained"`

	// IsClosing 締め状況
	IsClosing bool `json:"isClosing"`

	// IsError エラー勤務状況
	IsError bool `json:"isError"`

	// IsHelp ヘルプ勤務状況
	IsHelp bool `json:"isHelp"`

	// Late 遅刻時間（分）
	Late int `json:"late"`

	// LateNight 深夜時間（分）
	LateNight int `json:"lateNight"`

	// LateNightOvertime 深夜残業時間（分）
	LateNightOvertime int `json:"lateNightOvertime"`

	// LateNightUnassigned 深夜所定外時間（分）
	LateNightUnassigned int `json:"lateNightUnassigned"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`

	// TotalWork 労働合計時間（分）
	TotalWork int `json:"totalWork"`

	// Unassigned 所定外時間（分）
	Unassigned int `json:"unassigned"`

	// WorkPlaceDivisionCode 出勤先所属コード
	WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

	// WorkPlaceDivisionName 出勤先所属名
	WorkPlaceDivisionName *string `json:"workPlaceDivisionName,omitempty"`

	// WorkdayTypeName 勤務日種別名
	WorkdayTypeName string `json:"workdayTypeName"`
}

// DailyWorkingResponseAutoBreakOff 自動休憩無効（null： 休憩を無効化しない 1：　雇用区分休憩無効　2： スケジュール休憩無効　3： 全ての自動休憩無効）
type DailyWorkingResponseAutoBreakOff int

// DailyWorkingResponseCurrentDateEmployeeGender 性別（no_selected： 選択しない　male： 男性　female： 女性）
type DailyWorkingResponseCurrentDateEmployeeGender string

// DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode 計算単位コード（1： 日数　2： 時間　4： 数値）
type DailyWorkingResponseCustomDailyWorkingsCalculationUnitCode int

// DailyWorkingTimerecord 打刻
type DailyWorkingTimerecord struct {
	// Code 打刻種別コード
	Code DailyWorkingTimerecordCode `json:"code"`

	// DivisionCode 打刻所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 打刻所属名
	DivisionName string `json:"divisionName"`

	// Latitude 緯度
	Latitude float64 `json:"latitude"`

	// Longitude 経度
	Longitude float64 `json:"longitude"`

	// Name 打刻種別名
	Name string `json:"name"`

	// Time 打刻時間
	Time time.Time `json:"time"`
}

// DailyWorkingTimerecordCode 打刻種別コード
type DailyWorkingTimerecordCode string

// DailyWorkingTimerecordRequest defines model for daily_working_timerecord_request.
type DailyWorkingTimerecordRequest struct {
	// Code 打刻種別コード（1： 出勤　2： 退勤　3： 休憩開始　4： 休憩終了　7： 外出入　8： 外出戻）
	// 省略時は、KING OF TIMEの処理に従って打刻種別を決定します。
	Code *DailyWorkingTimerecordRequestCode `json:"code,omitempty"`

	// Date 勤務日
	// 指定された勤務日に打刻データが紐づきます。
	Date openapi_types.Date `json:"date"`

	// DivisionCode 打刻先所属コード
	// 省略時は、該当従業員が所属している所属を打刻先所属として扱います。
	DivisionCode *string `json:"divisionCode,omitempty"`

	// Latitude 緯度
	Latitude *float64 `json:"latitude,omitempty"`

	// Longitude 経度
	Longitude *float64 `json:"longitude,omitempty"`

	// Time 打刻時間
	Time time.Time `json:"time"`
}

// DailyWorkingTimerecordRequestCode 打刻種別コード（1： 出勤　2： 退勤　3： 休憩開始　4： 休憩終了　7： 外出入　8： 外出戻）
// 省略時は、KING OF TIMEの処理に従って打刻種別を決定します。
type DailyWorkingTimerecordRequestCode string

// DivisionResponse defines model for division_response.
type DivisionResponse struct {
	// Code 所属コード
	Code string `json:"code"`

	// DayBorderTime 所属名
	DayBorderTime string `json:"dayBorderTime"`

	// Name 所属名
	Name string `json:"name"`
}

// EmployeeRequest defines model for employee_request.
type EmployeeRequest struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender string `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`
}

// EmployeeResponse defines model for employee_response.
type EmployeeResponse struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []struct {
		// Code 従業員グループコード
		Code string `json:"code"`

		// Name 従業員グループ名
		Name string `json:"name"`
	} `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender string `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// WorkingTypeResponse defines model for working_type_response.
type WorkingTypeResponse struct {
	// Code 雇用区分コード
	Code string `json:"code"`

	// Name 雇用区分名
	Name string `json:"name"`
}

// AdditionalFieldsAdministrator defines model for additionalFields_administrator.
type AdditionalFieldsAdministrator = []string

// AdditionalFieldsDailyWorkings defines model for additionalFields_daily-workings.
type AdditionalFieldsDailyWorkings = []string

// AdditionalFieldsEmployee defines model for additionalFields_employee.
type AdditionalFieldsEmployee = []string

// AdditionalFieldsEmployeeGroups defines model for additionalFields_employee-groups.
type AdditionalFieldsEmployeeGroups = []string

// Date defaultは当日
type Date = openapi_types.Date

// DateRequired defaultは当日
type DateRequired = openapi_types.Date

// Division defines model for division.
type Division = string

// EmployeeCode defines model for employeeCode.
type EmployeeCode = string

// EmployeeKey defines model for employeeKey.
type EmployeeKey = string

// EmployeeKeys defines model for employeeKeys.
type EmployeeKeys = []string

// End defaultは当日
type End = openapi_types.Date

// IncludeResigner defines model for includeResigner.
type IncludeResigner = bool

// Ondivision defines model for ondivision.
type Ondivision = bool

// Start defaultは当日
type Start = openapi_types.Date

// Token defines model for token.
type Token = string

// UpdateDate defaultは当日
type UpdateDate = openapi_types.Date

// GetAdministratorsParams defines parameters for GetAdministrators.
type GetAdministratorsParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsAdministrator `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetAdministratorsParamsAdditionalFields defines parameters for GetAdministrators.
type GetAdministratorsParamsAdditionalFields string

// GetDailyWorkingsParams defines parameters for GetDailyWorkings.
type GetDailyWorkingsParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// Start 取得したい期間の開始年月日
	// ・過去日は最大3年前まで
	Start *Start `form:"start,omitempty" json:"start,omitempty"`

	// End 取得したい期間の終了年月日
	// ・startとendは同時に指定
	// ・期間は最大62日
	// ・未来日は最大1年後まで
	End *End `form:"end,omitempty" json:"end,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingsParamsAdditionalFields defines parameters for GetDailyWorkings.
type GetDailyWorkingsParamsAdditionalFields string

// GetDailyWorkingTimerecordsParams defines parameters for GetDailyWorkingTimerecords.
type GetDailyWorkingTimerecordsParams struct {
	// EmployeeKeys 従業員識別キー（従業員コードが変更されても不変）
	// ,区切りで複数従業員の指定可能
	// divisionが指定されていない場合のみ使用可能
	EmployeeKeys *EmployeeKeys `form:"employeeKeys,omitempty" json:"employeeKeys,omitempty"`

	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// Start 取得したい期間の開始年月日
	// ・過去日は最大3年前まで
	Start *Start `form:"start,omitempty" json:"start,omitempty"`

	// End 取得したい期間の終了年月日
	// ・startとendは同時に指定
	// ・期間は最大62日
	// ・未来日は最大1年後まで
	End *End `form:"end,omitempty" json:"end,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingTimerecordsParamsAdditionalFields defines parameters for GetDailyWorkingTimerecords.
type GetDailyWorkingTimerecordsParamsAdditionalFields string

// GetDailyWorkingTimerecordParams defines parameters for GetDailyWorkingTimerecord.
type GetDailyWorkingTimerecordParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingTimerecordParamsAdditionalFields defines parameters for GetDailyWorkingTimerecord.
type GetDailyWorkingTimerecordParamsAdditionalFields string

// GetDailyWorkingParams defines parameters for GetDailyWorking.
type GetDailyWorkingParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingParamsAdditionalFields defines parameters for GetDailyWorking.
type GetDailyWorkingParamsAdditionalFields string

// GetEmployeeGroupsParams defines parameters for GetEmployeeGroups.
type GetEmployeeGroupsParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployeeGroups `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeeGroupsParamsAdditionalFields defines parameters for GetEmployeeGroups.
type GetEmployeeGroupsParamsAdditionalFields string

// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams struct {
	// Date 指定された年月日時点での従業員のデータを表示
	// ・過去日は最大3年前まで
	// ・未来日は最大1年後まで
	Date *Date `form:"date,omitempty" json:"date,omitempty"`

	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// IncludeResigner 指定された年月日時点で退職済みの従業員を含む場合 True
	IncludeResigner *IncludeResigner `form:"includeResigner,omitempty" json:"includeResigner,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployee `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeesParamsAdditionalFields defines parameters for GetEmployees.
type GetEmployeesParamsAdditionalFields string

// GetEmployeeParams defines parameters for GetEmployee.
type GetEmployeeParams struct {
	// Date 指定された年月日時点での従業員のデータを表示
	// ・過去日は最大3年前まで
	// ・未来日は最大1年後まで
	Date *Date `form:"date,omitempty" json:"date,omitempty"`

	// IncludeResigner 指定された年月日時点で退職済みの従業員を含む場合 True
	IncludeResigner *IncludeResigner `form:"includeResigner,omitempty" json:"includeResigner,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployee `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeeParamsAdditionalFields defines parameters for GetEmployee.
type GetEmployeeParamsAdditionalFields string

// UpdateEmployeeJSONBody defines parameters for UpdateEmployee.
type UpdateEmployeeJSONBody struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code *string `json:"code,omitempty"`

	// DivisionCode 所属コード
	DivisionCode *string `json:"divisionCode,omitempty"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// FirstName 名
	FirstName *string `json:"firstName,omitempty"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender *string `json:"gender,omitempty"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// LastName 姓
	LastName *string `json:"lastName,omitempty"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode *string `json:"typeCode,omitempty"`
}

// UpdateEmployeeParams defines parameters for UpdateEmployee.
type UpdateEmployeeParams struct {
	// UpdateDate 所属、雇用区分を更新したい年月日
	UpdateDate *UpdateDate `form:"updateDate,omitempty" json:"updateDate,omitempty"`
}

// GetOvertimesParams defines parameters for GetOvertimes.
type GetOvertimesParams struct {
	// AdministratorKey 管理者識別キー（管理者コードが変更されても不変）
	AdministratorKey *string `form:"administratorKey,omitempty" json:"administratorKey,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *[]GetOvertimesParamsAdditionalFields `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetOvertimesParamsAdditionalFields defines parameters for GetOvertimes.
type GetOvertimesParamsAdditionalFields string

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// AdministratorKey 管理者識別キー（管理者コードが変更されても不変）
	AdministratorKey *string `form:"administratorKey,omitempty" json:"administratorKey,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *[]GetSchedulesParamsAdditionalFields `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetSchedulesParamsAdditionalFields defines parameters for GetSchedules.
type GetSchedulesParamsAdditionalFields string

// RegisterDailyWorkingTimerecordJSONRequestBody defines body for RegisterDailyWorkingTimerecord for application/json ContentType.
type RegisterDailyWorkingTimerecordJSONRequestBody = DailyWorkingTimerecordRequest

// RegisterEmployeeJSONRequestBody defines body for RegisterEmployee for application/json ContentType.
type RegisterEmployeeJSONRequestBody = EmployeeRequest

// UpdateEmployeeJSONRequestBody defines body for UpdateEmployee for application/json ContentType.
type UpdateEmployeeJSONRequestBody UpdateEmployeeJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAdministrators request
	GetAdministrators(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompany request
	GetCompany(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkings request
	GetDailyWorkings(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingTimerecords request
	GetDailyWorkingTimerecords(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingTimerecord request
	GetDailyWorkingTimerecord(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterDailyWorkingTimerecord request with any body
	RegisterDailyWorkingTimerecordWithBody(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterDailyWorkingTimerecord(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorking request
	GetDailyWorking(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDivisions request
	GetDivisions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployeeGroups request
	GetEmployeeGroups(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployees request
	GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterEmployee request with any body
	RegisterEmployeeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterEmployee(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployee request
	GetEmployee(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmployee request
	DeleteEmployee(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBody(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmployee(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOvertimes request
	GetOvertimes(ctx context.Context, date string, params *GetOvertimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendAccessToken request
	SuspendAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAccessToken request
	RefreshAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessTokenAvailability request
	GetAccessTokenAvailability(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkingTypes request
	GetWorkingTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAdministrators(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdministratorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompany(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkings(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingTimerecords(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingTimerecordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingTimerecord(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingTimerecordRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterDailyWorkingTimerecordWithBody(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterDailyWorkingTimerecordRequestWithBody(c.Server, employeeKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterDailyWorkingTimerecord(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterDailyWorkingTimerecordRequest(c.Server, employeeKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorking(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDivisions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDivisionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployeeGroups(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeeGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEmployeeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEmployeeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEmployee(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEmployeeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployee(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeeRequest(c.Server, employeeCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmployee(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmployeeRequest(c.Server, employeeKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployeeWithBody(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequestWithBody(c.Server, employeeKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployee(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequest(c.Server, employeeKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOvertimes(ctx context.Context, date string, params *GetOvertimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOvertimesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendAccessTokenRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessTokenAvailability(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessTokenAvailabilityRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkingTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkingTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAdministratorsRequest generates requests for GetAdministrators
func NewGetAdministratorsRequest(server string, params *GetAdministratorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/administrators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyRequest generates requests for GetCompany
func NewGetCompanyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/company")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingsRequest generates requests for GetDailyWorkings
func NewGetDailyWorkingsRequest(server string, params *GetDailyWorkingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingTimerecordsRequest generates requests for GetDailyWorkingTimerecords
func NewGetDailyWorkingTimerecordsRequest(server string, params *GetDailyWorkingTimerecordsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EmployeeKeys != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "employeeKeys", runtime.ParamLocationQuery, *params.EmployeeKeys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingTimerecordRequest generates requests for GetDailyWorkingTimerecord
func NewGetDailyWorkingTimerecordRequest(server string, date DateRequired, params *GetDailyWorkingTimerecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterDailyWorkingTimerecordRequest calls the generic RegisterDailyWorkingTimerecord builder with application/json body
func NewRegisterDailyWorkingTimerecordRequest(server string, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterDailyWorkingTimerecordRequestWithBody(server, employeeKey, "application/json", bodyReader)
}

// NewRegisterDailyWorkingTimerecordRequestWithBody generates requests for RegisterDailyWorkingTimerecord with any type of body
func NewRegisterDailyWorkingTimerecordRequestWithBody(server string, employeeKey EmployeeKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDailyWorkingRequest generates requests for GetDailyWorking
func NewGetDailyWorkingRequest(server string, date DateRequired, params *GetDailyWorkingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDivisionsRequest generates requests for GetDivisions
func NewGetDivisionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/divisions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeeGroupsRequest generates requests for GetEmployeeGroups
func NewGetEmployeeGroupsRequest(server string, params *GetEmployeeGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employee-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeResigner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeResigner", runtime.ParamLocationQuery, *params.IncludeResigner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterEmployeeRequest calls the generic RegisterEmployee builder with application/json body
func NewRegisterEmployeeRequest(server string, body RegisterEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterEmployeeRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterEmployeeRequestWithBody generates requests for RegisterEmployee with any type of body
func NewRegisterEmployeeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEmployeeRequest generates requests for GetEmployee
func NewGetEmployeeRequest(server string, employeeCode EmployeeCode, params *GetEmployeeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeCode", runtime.ParamLocationPath, employeeCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeResigner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeResigner", runtime.ParamLocationQuery, *params.IncludeResigner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEmployeeRequest generates requests for DeleteEmployee
func NewDeleteEmployeeRequest(server string, employeeKey EmployeeKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEmployeeRequest calls the generic UpdateEmployee builder with application/json body
func NewUpdateEmployeeRequest(server string, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmployeeRequestWithBody(server, employeeKey, params, "application/json", bodyReader)
}

// NewUpdateEmployeeRequestWithBody generates requests for UpdateEmployee with any type of body
func NewUpdateEmployeeRequestWithBody(server string, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateDate", runtime.ParamLocationQuery, *params.UpdateDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOvertimesRequest generates requests for GetOvertimes
func NewGetOvertimesRequest(server string, date string, params *GetOvertimesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/overtimes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdministratorKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "administratorKey", runtime.ParamLocationQuery, *params.AdministratorKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, date string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdministratorKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "administratorKey", runtime.ParamLocationQuery, *params.AdministratorKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuspendAccessTokenRequest generates requests for SuspendAccessToken
func NewSuspendAccessTokenRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshAccessTokenRequest generates requests for RefreshAccessToken
func NewRefreshAccessTokenRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessTokenAvailabilityRequest generates requests for GetAccessTokenAvailability
func NewGetAccessTokenAvailabilityRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s/available", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkingTypesRequest generates requests for GetWorkingTypes
func NewGetWorkingTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/working-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAdministrators request
	GetAdministratorsWithResponse(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*GetAdministratorsResponse, error)

	// GetCompany request
	GetCompanyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error)

	// GetDailyWorkings request
	GetDailyWorkingsWithResponse(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingsResponse, error)

	// GetDailyWorkingTimerecords request
	GetDailyWorkingTimerecordsWithResponse(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordsResponse, error)

	// GetDailyWorkingTimerecord request
	GetDailyWorkingTimerecordWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordResponse, error)

	// RegisterDailyWorkingTimerecord request with any body
	RegisterDailyWorkingTimerecordWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error)

	RegisterDailyWorkingTimerecordWithResponse(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error)

	// GetDailyWorking request
	GetDailyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingResponse, error)

	// GetDivisions request
	GetDivisionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDivisionsResponse, error)

	// GetEmployeeGroups request
	GetEmployeeGroupsWithResponse(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*GetEmployeeGroupsResponse, error)

	// GetEmployees request
	GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesResponse, error)

	// RegisterEmployee request with any body
	RegisterEmployeeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error)

	RegisterEmployeeWithResponse(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error)

	// GetEmployee request
	GetEmployeeWithResponse(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error)

	// DeleteEmployee request
	DeleteEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	UpdateEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	// GetOvertimes request
	GetOvertimesWithResponse(ctx context.Context, date string, params *GetOvertimesParams, reqEditors ...RequestEditorFn) (*GetOvertimesResponse, error)

	// GetSchedules request
	GetSchedulesWithResponse(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// SuspendAccessToken request
	SuspendAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*SuspendAccessTokenResponse, error)

	// RefreshAccessToken request
	RefreshAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	// GetAccessTokenAvailability request
	GetAccessTokenAvailabilityWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*GetAccessTokenAvailabilityResponse, error)

	// GetWorkingTypes request
	GetWorkingTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkingTypesResponse, error)
}

type GetAdministratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AssociatedEmployees *[]struct {
			// Code 従業員コード
			Code string `json:"code"`

			// FirstName 名
			FirstName string `json:"firstName"`

			// Key 従業員識別キー（従業員コードが変更されても不変）
			Key string `json:"key"`

			// LastName 姓
			LastName string `json:"lastName"`
		} `json:"associatedEmployees,omitempty"`

		// Code 管理者コード
		Code string `json:"code"`

		// EmailAddresses メールアドレス
		EmailAddresses *openapi_types.Email `json:"emailAddresses,omitempty"`

		// Key 管理者識別キー（管理者コードが変更されても不変）
		Key string `json:"key"`

		// Name 管理者名
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAdministratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdministratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BusinessYearStartDate 事業年度開始日
		BusinessYearStartDate string `json:"businessYearStartDate"`

		// Code 企業コード
		Code string `json:"code"`

		// Host ホスト名
		Host string `json:"host"`

		// Key 企業識別キー
		Key string `json:"key"`

		// Name 企業名
		Name string `json:"name"`

		// Settings 企業設定情報
		Settings struct {
			// DecimalTreatType 10進表示の小数第3位の扱い（roundDown： 切下げ　roundUp： 切上げ　round： 四捨五入）
			DecimalTreatType string `json:"decimalTreatType"`

			// TimeDisplayFormat 表示形式（decimal： 10進法　sexagesimal： 60進法）
			TimeDisplayFormat string `json:"timeDisplayFormat"`
		} `json:"settings"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DailyWorkingResponse
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingTimerecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CurrentDateEmployee 今日時点の従業員データ
		CurrentDateEmployee *struct {
			// Code 従業員コード
			Code string `json:"code"`

			// DivisionCode 所属コード
			DivisionCode string `json:"divisionCode"`

			// DivisionName 所属名
			DivisionName string `json:"divisionName"`

			// EmployeeGroups 従業員グループ情報
			EmployeeGroups []struct {
				// Code 従業員グループコード
				Code string `json:"code"`

				// Name 従業員グループ名
				Name string `json:"name"`
			} `json:"employeeGroups"`

			// FirstName 名
			FirstName string `json:"firstName"`

			// FirstNamePhonetics 名（カナ）
			FirstNamePhonetics string `json:"firstNamePhonetics"`

			// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
			Gender N200CurrentDateEmployeeGender `json:"gender"`

			// LastName 姓
			LastName string `json:"lastName"`

			// LastNamePhonetics 姓（カナ）
			LastNamePhonetics string `json:"lastNamePhonetics"`

			// TypeCode 雇用区分コード
			TypeCode string `json:"typeCode"`

			// TypeName 雇用区分名
			TypeName string `json:"typeName"`
		} `json:"currentDateEmployee,omitempty"`

		// Date 日時
		Date openapi_types.Date `json:"date"`

		// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
		EmployeeKey string `json:"employeeKey"`

		// TimeRecord 打刻
		TimeRecord []DailyWorkingTimerecord `json:"timeRecord"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingTimerecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingTimerecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingTimerecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DailyWorkings []DailyWorkingTimerecord `json:"dailyWorkings"`
		Date          openapi_types.Date       `json:"date"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingTimerecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingTimerecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterDailyWorkingTimerecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Date 日時
		Date openapi_types.Date `json:"date"`

		// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
		EmployeeKey string `json:"employeeKey"`

		// TimeRecord 打刻
		TimeRecord DailyWorkingTimerecord `json:"timeRecord"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterDailyWorkingTimerecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterDailyWorkingTimerecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyWorkingResponse
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDivisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DivisionResponse
}

// Status returns HTTPResponse.Status
func (r GetDivisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDivisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Category 従業員グループカテゴリ
		Category *struct {
			// Code 従業員グループカテゴリコード
			Code string `json:"code"`

			// Name 従業員グループカテゴリ名
			Name string `json:"name"`
		} `json:"category,omitempty"`

		// Code 従業員グループコード
		Code string `json:"code"`

		// Name 従業員グループ名
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEmployeeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EmployeeResponse
}

// Status returns HTTPResponse.Status
func (r GetEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Code 従業員コード
		Code string `json:"code"`

		// DivisionCode 所属コード
		DivisionCode string `json:"divisionCode"`

		// FirstName 名
		FirstName string `json:"firstName"`

		// Gender 性別（male： 男性　female： 女性）
		Gender string `json:"gender"`

		// Key 従業員識別キー（従業員コードが変更されても不変）
		Key string `json:"key"`

		// LastName 姓
		LastName string `json:"lastName"`

		// TypeCode 雇用区分コード
		TypeCode string `json:"typeCode"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmployeeResponse
}

// Status returns HTTPResponse.Status
func (r GetEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmployeeResponse
}

// Status returns HTTPResponse.Status
func (r UpdateEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOvertimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Month            int `json:"month"`
		OvertimeRequests []struct {
			// AdminComment 管理者コメント
			AdminComment string `json:"adminComment"`

			// Applicant 申請者
			Applicant struct {
				// Key 識別キー（従業員 または 管理者）
				Key string `json:"key"`

				// Type 種別（employee： 従業員　administrator： 管理者)
				Type N200OvertimeRequestsApplicantType `json:"type"`
			} `json:"applicant"`

			// Current 現在のスケジュール
			Current struct {
				// End 終了時刻
				End KotDate `json:"end"`

				// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
				IsBeforeSchedule bool `json:"isBeforeSchedule"`

				// Start 開始時刻
				Start KotDate `json:"start"`
			} `json:"current"`

			// CurrentFlow 現在の承認フローレベル（１～５）
			CurrentFlow N200OvertimeRequestsCurrentFlow `json:"currentFlow"`

			// Date 対象日
			Date openapi_types.Date `json:"date"`

			// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
			EmployeeKey string `json:"employeeKey"`

			// Flow 承認フロー
			Flow *[]struct {
				// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
				AdministratorKeys []string `json:"administratorKeys"`

				// Level 承認フローレベル（１～５）
				Level N200OvertimeRequestsFlowLevel `json:"level"`
			} `json:"flow,omitempty"`

			// LastModifiedAdministratorKey 最終更新管理者識別キー
			LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

			// Message 申請メッセージ
			Message string `json:"message"`

			// RequestKey 申請識別キー
			RequestKey string `json:"requestKey"`

			// Requested 申請内容
			Requested struct {
				// End 終了時刻
				End KotDate `json:"end"`

				// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
				IsBeforeSchedule bool `json:"isBeforeSchedule"`

				// Start 開始時刻
				Start KotDate `json:"start"`
			} `json:"requested"`

			// RequestedDate 申請日
			RequestedDate openapi_types.Date `json:"requestedDate"`

			// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
			Status N200OvertimeRequestsStatus `json:"status"`
		} `json:"overtimeRequests"`
		Year int `json:"year"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOvertimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOvertimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Month            int32 `json:"month"`
		ScheduleRequests []struct {
			// AdminComment 管理者コメント
			AdminComment string `json:"adminComment"`
			Applicant    struct {
				// Key 識別キー（従業員 または 管理者）
				Key string `json:"key"`

				// Type 種別（employee： 従業員　administrator： 管理者)
				Type N200ScheduleRequestsApplicantType `json:"type"`
			} `json:"applicant"`
			Current struct {
				// BreakSchedule 休憩予定時間（分）
				BreakSchedule int32 `json:"breakSchedule"`

				// ClockInSchedule 出勤予定時間
				ClockInSchedule KotDate `json:"clockInSchedule"`

				// ClockOutSchedule 退勤予定時間
				ClockOutSchedule KotDate `json:"clockOutSchedule"`

				// HolidaysObtained 休暇取得
				HolidaysObtained struct {
					FulltimeHoliday struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// Name 休暇区分名
						Name string `json:"name"`
					} `json:"fulltimeHoliday"`
					HalfdayHolidays []struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// Name 休暇区分名
						Name string `json:"name"`

						// TypeName 半休種別名
						TypeName string `json:"typeName"`
					} `json:"halfdayHolidays"`
					HourHolidays []struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// End 休暇終了予定
						End KotDate `json:"end"`

						// Minutes 休暇取得時間
						Minutes int32 `json:"minutes"`

						// Name 休暇区分名
						Name string `json:"name"`

						// Start 休暇開始予定
						Start KotDate `json:"start"`
					} `json:"hourHolidays"`
				} `json:"holidaysObtained"`

				// OvertimeUpperLimit 残業上限時間（分）
				OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

				// ScheduleTypeName スケジュール種別
				ScheduleTypeName string `json:"scheduleTypeName"`

				// StartEndBreakSchedule 休憩開始終了予定
				StartEndBreakSchedule []struct {
					// End 休憩終了予定
					End KotDate `json:"end"`

					// Start 休憩開始予定
					Start KotDate `json:"start"`
				} `json:"startEndBreakSchedule"`

				// SubstitutionClockInName 振替出勤
				SubstitutionClockInName string `json:"substitutionClockInName"`

				// WorkDayTypeName 勤務日種別名
				WorkDayTypeName string `json:"workDayTypeName"`

				// WorkPlaceDivisionCode 出勤先所属コード
				WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

				// WorkPlaceDivisionName 出勤先所属名
				WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
			} `json:"current"`

			// CurrentFlow 現在の承認フローレベル（１～５）
			CurrentFlow N200ScheduleRequestsCurrentFlow `json:"currentFlow"`

			// Date 対象日
			Date openapi_types.Date `json:"date"`

			// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
			EmployeeKey string `json:"employeeKey"`

			// Flow 承認フロー
			Flow *[]struct {
				// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
				AdministratorKeys []string `json:"administratorKeys"`

				// Level 承認フローレベル（１～５）
				Level N200ScheduleRequestsFlowLevel `json:"level"`
			} `json:"flow,omitempty"`

			// LastModifiedAdministratorKey 最終更新管理者識別キー
			LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

			// Message 申請メッセージ
			Message string `json:"message"`

			// Note 備考
			Note *string `json:"note,omitempty"`

			// RequestKey 申請識別キー
			RequestKey string `json:"requestKey"`
			Requested  struct {
				// BreakSchedule 休憩予定時間（分）
				BreakSchedule int32 `json:"breakSchedule"`

				// ClockInSchedule 出勤予定時間
				ClockInSchedule KotDate `json:"clockInSchedule"`

				// ClockOutSchedule 退勤予定時間
				ClockOutSchedule KotDate `json:"clockOutSchedule"`

				// HolidaysObtained 休暇取得
				HolidaysObtained struct {
					FulltimeHoliday struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// Name 休暇区分名
						Name string `json:"name"`
					} `json:"fulltimeHoliday"`
					HalfdayHolidays []struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// Name 休暇区分名
						Name string `json:"name"`

						// TypeName 半休種別名
						TypeName string `json:"typeName"`
					} `json:"halfdayHolidays"`
					HourHolidays []struct {
						// Code 休暇区分コード
						Code int `json:"code"`

						// End 休暇終了予定
						End KotDate `json:"end"`

						// Minutes 休暇取得時間
						Minutes int32 `json:"minutes"`

						// Name 休暇区分名
						Name string `json:"name"`

						// Start 休暇開始予定
						Start KotDate `json:"start"`
					} `json:"hourHolidays"`
				} `json:"holidaysObtained"`

				// OvertimeUpperLimit 残業上限時間（分）
				OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

				// ScheduleTypeName スケジュール種別
				ScheduleTypeName string `json:"scheduleTypeName"`

				// StartEndBreakSchedule 休憩開始終了予定
				StartEndBreakSchedule []struct {
					// End 休憩終了予定
					End KotDate `json:"end"`

					// Start 休憩開始予定
					Start KotDate `json:"start"`
				} `json:"startEndBreakSchedule"`

				// SubstitutionClockInName 振替出勤
				SubstitutionClockInName string `json:"substitutionClockInName"`

				// WorkDayTypeName 勤務日種別名
				WorkDayTypeName string `json:"workDayTypeName"`

				// WorkPlaceDivisionCode 出勤先所属コード
				WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

				// WorkPlaceDivisionName 出勤先所属名
				WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
			} `json:"requested"`

			// RequestedDate 申請日
			RequestedDate openapi_types.Date `json:"requestedDate"`

			// SchedulePatternCode スケジュールパターンコード
			SchedulePatternCode *string `json:"schedulePatternCode,omitempty"`

			// SchedulePatternName スケジュールパターン名
			SchedulePatternName *string `json:"schedulePatternName,omitempty"`

			// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
			Status N200ScheduleRequestsStatus `json:"status"`

			// WorkFixedEnd 勤務終了刻限
			WorkFixedEnd *KotDate `json:"workFixedEnd,omitempty"`

			// WorkFixedStart 勤務開始刻限
			WorkFixedStart *KotDate `json:"workFixedStart,omitempty"`
		} `json:"scheduleRequests"`
		Year int32 `json:"year"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SuspendAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Token refreshed access token
		Token string `json:"token"`
	}
}

// Status returns HTTPResponse.Status
func (r RefreshAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessTokenAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Available bool `json:"available"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAccessTokenAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessTokenAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkingTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkingTypeResponse
}

// Status returns HTTPResponse.Status
func (r GetWorkingTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkingTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAdministratorsWithResponse request returning *GetAdministratorsResponse
func (c *ClientWithResponses) GetAdministratorsWithResponse(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*GetAdministratorsResponse, error) {
	rsp, err := c.GetAdministrators(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdministratorsResponse(rsp)
}

// GetCompanyWithResponse request returning *GetCompanyResponse
func (c *ClientWithResponses) GetCompanyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error) {
	rsp, err := c.GetCompany(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyResponse(rsp)
}

// GetDailyWorkingsWithResponse request returning *GetDailyWorkingsResponse
func (c *ClientWithResponses) GetDailyWorkingsWithResponse(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingsResponse, error) {
	rsp, err := c.GetDailyWorkings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingsResponse(rsp)
}

// GetDailyWorkingTimerecordsWithResponse request returning *GetDailyWorkingTimerecordsResponse
func (c *ClientWithResponses) GetDailyWorkingTimerecordsWithResponse(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordsResponse, error) {
	rsp, err := c.GetDailyWorkingTimerecords(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingTimerecordsResponse(rsp)
}

// GetDailyWorkingTimerecordWithResponse request returning *GetDailyWorkingTimerecordResponse
func (c *ClientWithResponses) GetDailyWorkingTimerecordWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordResponse, error) {
	rsp, err := c.GetDailyWorkingTimerecord(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingTimerecordResponse(rsp)
}

// RegisterDailyWorkingTimerecordWithBodyWithResponse request with arbitrary body returning *RegisterDailyWorkingTimerecordResponse
func (c *ClientWithResponses) RegisterDailyWorkingTimerecordWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error) {
	rsp, err := c.RegisterDailyWorkingTimerecordWithBody(ctx, employeeKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterDailyWorkingTimerecordResponse(rsp)
}

func (c *ClientWithResponses) RegisterDailyWorkingTimerecordWithResponse(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error) {
	rsp, err := c.RegisterDailyWorkingTimerecord(ctx, employeeKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterDailyWorkingTimerecordResponse(rsp)
}

// GetDailyWorkingWithResponse request returning *GetDailyWorkingResponse
func (c *ClientWithResponses) GetDailyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingResponse, error) {
	rsp, err := c.GetDailyWorking(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingResponse(rsp)
}

// GetDivisionsWithResponse request returning *GetDivisionsResponse
func (c *ClientWithResponses) GetDivisionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDivisionsResponse, error) {
	rsp, err := c.GetDivisions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDivisionsResponse(rsp)
}

// GetEmployeeGroupsWithResponse request returning *GetEmployeeGroupsResponse
func (c *ClientWithResponses) GetEmployeeGroupsWithResponse(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*GetEmployeeGroupsResponse, error) {
	rsp, err := c.GetEmployeeGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeeGroupsResponse(rsp)
}

// GetEmployeesWithResponse request returning *GetEmployeesResponse
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesResponse, error) {
	rsp, err := c.GetEmployees(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesResponse(rsp)
}

// RegisterEmployeeWithBodyWithResponse request with arbitrary body returning *RegisterEmployeeResponse
func (c *ClientWithResponses) RegisterEmployeeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error) {
	rsp, err := c.RegisterEmployeeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEmployeeResponse(rsp)
}

func (c *ClientWithResponses) RegisterEmployeeWithResponse(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error) {
	rsp, err := c.RegisterEmployee(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEmployeeResponse(rsp)
}

// GetEmployeeWithResponse request returning *GetEmployeeResponse
func (c *ClientWithResponses) GetEmployeeWithResponse(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error) {
	rsp, err := c.GetEmployee(ctx, employeeCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeeResponse(rsp)
}

// DeleteEmployeeWithResponse request returning *DeleteEmployeeResponse
func (c *ClientWithResponses) DeleteEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error) {
	rsp, err := c.DeleteEmployee(ctx, employeeKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmployeeResponse(rsp)
}

// UpdateEmployeeWithBodyWithResponse request with arbitrary body returning *UpdateEmployeeResponse
func (c *ClientWithResponses) UpdateEmployeeWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployeeWithBody(ctx, employeeKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployee(ctx, employeeKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

// GetOvertimesWithResponse request returning *GetOvertimesResponse
func (c *ClientWithResponses) GetOvertimesWithResponse(ctx context.Context, date string, params *GetOvertimesParams, reqEditors ...RequestEditorFn) (*GetOvertimesResponse, error) {
	rsp, err := c.GetOvertimes(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOvertimesResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// SuspendAccessTokenWithResponse request returning *SuspendAccessTokenResponse
func (c *ClientWithResponses) SuspendAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*SuspendAccessTokenResponse, error) {
	rsp, err := c.SuspendAccessToken(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendAccessTokenResponse(rsp)
}

// RefreshAccessTokenWithResponse request returning *RefreshAccessTokenResponse
func (c *ClientWithResponses) RefreshAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessToken(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

// GetAccessTokenAvailabilityWithResponse request returning *GetAccessTokenAvailabilityResponse
func (c *ClientWithResponses) GetAccessTokenAvailabilityWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*GetAccessTokenAvailabilityResponse, error) {
	rsp, err := c.GetAccessTokenAvailability(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessTokenAvailabilityResponse(rsp)
}

// GetWorkingTypesWithResponse request returning *GetWorkingTypesResponse
func (c *ClientWithResponses) GetWorkingTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkingTypesResponse, error) {
	rsp, err := c.GetWorkingTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkingTypesResponse(rsp)
}

// ParseGetAdministratorsResponse parses an HTTP response from a GetAdministratorsWithResponse call
func ParseGetAdministratorsResponse(rsp *http.Response) (*GetAdministratorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdministratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AssociatedEmployees *[]struct {
				// Code 従業員コード
				Code string `json:"code"`

				// FirstName 名
				FirstName string `json:"firstName"`

				// Key 従業員識別キー（従業員コードが変更されても不変）
				Key string `json:"key"`

				// LastName 姓
				LastName string `json:"lastName"`
			} `json:"associatedEmployees,omitempty"`

			// Code 管理者コード
			Code string `json:"code"`

			// EmailAddresses メールアドレス
			EmailAddresses *openapi_types.Email `json:"emailAddresses,omitempty"`

			// Key 管理者識別キー（管理者コードが変更されても不変）
			Key string `json:"key"`

			// Name 管理者名
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyResponse parses an HTTP response from a GetCompanyWithResponse call
func ParseGetCompanyResponse(rsp *http.Response) (*GetCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BusinessYearStartDate 事業年度開始日
			BusinessYearStartDate string `json:"businessYearStartDate"`

			// Code 企業コード
			Code string `json:"code"`

			// Host ホスト名
			Host string `json:"host"`

			// Key 企業識別キー
			Key string `json:"key"`

			// Name 企業名
			Name string `json:"name"`

			// Settings 企業設定情報
			Settings struct {
				// DecimalTreatType 10進表示の小数第3位の扱い（roundDown： 切下げ　roundUp： 切上げ　round： 四捨五入）
				DecimalTreatType string `json:"decimalTreatType"`

				// TimeDisplayFormat 表示形式（decimal： 10進法　sexagesimal： 60進法）
				TimeDisplayFormat string `json:"timeDisplayFormat"`
			} `json:"settings"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingsResponse parses an HTTP response from a GetDailyWorkingsWithResponse call
func ParseGetDailyWorkingsResponse(rsp *http.Response) (*GetDailyWorkingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DailyWorkingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingTimerecordsResponse parses an HTTP response from a GetDailyWorkingTimerecordsWithResponse call
func ParseGetDailyWorkingTimerecordsResponse(rsp *http.Response) (*GetDailyWorkingTimerecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingTimerecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CurrentDateEmployee 今日時点の従業員データ
			CurrentDateEmployee *struct {
				// Code 従業員コード
				Code string `json:"code"`

				// DivisionCode 所属コード
				DivisionCode string `json:"divisionCode"`

				// DivisionName 所属名
				DivisionName string `json:"divisionName"`

				// EmployeeGroups 従業員グループ情報
				EmployeeGroups []struct {
					// Code 従業員グループコード
					Code string `json:"code"`

					// Name 従業員グループ名
					Name string `json:"name"`
				} `json:"employeeGroups"`

				// FirstName 名
				FirstName string `json:"firstName"`

				// FirstNamePhonetics 名（カナ）
				FirstNamePhonetics string `json:"firstNamePhonetics"`

				// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
				Gender N200CurrentDateEmployeeGender `json:"gender"`

				// LastName 姓
				LastName string `json:"lastName"`

				// LastNamePhonetics 姓（カナ）
				LastNamePhonetics string `json:"lastNamePhonetics"`

				// TypeCode 雇用区分コード
				TypeCode string `json:"typeCode"`

				// TypeName 雇用区分名
				TypeName string `json:"typeName"`
			} `json:"currentDateEmployee,omitempty"`

			// Date 日時
			Date openapi_types.Date `json:"date"`

			// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
			EmployeeKey string `json:"employeeKey"`

			// TimeRecord 打刻
			TimeRecord []DailyWorkingTimerecord `json:"timeRecord"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingTimerecordResponse parses an HTTP response from a GetDailyWorkingTimerecordWithResponse call
func ParseGetDailyWorkingTimerecordResponse(rsp *http.Response) (*GetDailyWorkingTimerecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingTimerecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DailyWorkings []DailyWorkingTimerecord `json:"dailyWorkings"`
			Date          openapi_types.Date       `json:"date"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterDailyWorkingTimerecordResponse parses an HTTP response from a RegisterDailyWorkingTimerecordWithResponse call
func ParseRegisterDailyWorkingTimerecordResponse(rsp *http.Response) (*RegisterDailyWorkingTimerecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterDailyWorkingTimerecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Date 日時
			Date openapi_types.Date `json:"date"`

			// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
			EmployeeKey string `json:"employeeKey"`

			// TimeRecord 打刻
			TimeRecord DailyWorkingTimerecord `json:"timeRecord"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingResponse parses an HTTP response from a GetDailyWorkingWithResponse call
func ParseGetDailyWorkingResponse(rsp *http.Response) (*GetDailyWorkingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyWorkingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDivisionsResponse parses an HTTP response from a GetDivisionsWithResponse call
func ParseGetDivisionsResponse(rsp *http.Response) (*GetDivisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDivisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DivisionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeeGroupsResponse parses an HTTP response from a GetEmployeeGroupsWithResponse call
func ParseGetEmployeeGroupsResponse(rsp *http.Response) (*GetEmployeeGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Category 従業員グループカテゴリ
			Category *struct {
				// Code 従業員グループカテゴリコード
				Code string `json:"code"`

				// Name 従業員グループカテゴリ名
				Name string `json:"name"`
			} `json:"category,omitempty"`

			// Code 従業員グループコード
			Code string `json:"code"`

			// Name 従業員グループ名
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeesResponse parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesResponse(rsp *http.Response) (*GetEmployeesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EmployeeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterEmployeeResponse parses an HTTP response from a RegisterEmployeeWithResponse call
func ParseRegisterEmployeeResponse(rsp *http.Response) (*RegisterEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Code 従業員コード
			Code string `json:"code"`

			// DivisionCode 所属コード
			DivisionCode string `json:"divisionCode"`

			// FirstName 名
			FirstName string `json:"firstName"`

			// Gender 性別（male： 男性　female： 女性）
			Gender string `json:"gender"`

			// Key 従業員識別キー（従業員コードが変更されても不変）
			Key string `json:"key"`

			// LastName 姓
			LastName string `json:"lastName"`

			// TypeCode 雇用区分コード
			TypeCode string `json:"typeCode"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetEmployeeResponse parses an HTTP response from a GetEmployeeWithResponse call
func ParseGetEmployeeResponse(rsp *http.Response) (*GetEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmployeeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEmployeeResponse parses an HTTP response from a DeleteEmployeeWithResponse call
func ParseDeleteEmployeeResponse(rsp *http.Response) (*DeleteEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateEmployeeResponse parses an HTTP response from a UpdateEmployeeWithResponse call
func ParseUpdateEmployeeResponse(rsp *http.Response) (*UpdateEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmployeeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOvertimesResponse parses an HTTP response from a GetOvertimesWithResponse call
func ParseGetOvertimesResponse(rsp *http.Response) (*GetOvertimesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOvertimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Month            int `json:"month"`
			OvertimeRequests []struct {
				// AdminComment 管理者コメント
				AdminComment string `json:"adminComment"`

				// Applicant 申請者
				Applicant struct {
					// Key 識別キー（従業員 または 管理者）
					Key string `json:"key"`

					// Type 種別（employee： 従業員　administrator： 管理者)
					Type N200OvertimeRequestsApplicantType `json:"type"`
				} `json:"applicant"`

				// Current 現在のスケジュール
				Current struct {
					// End 終了時刻
					End KotDate `json:"end"`

					// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
					IsBeforeSchedule bool `json:"isBeforeSchedule"`

					// Start 開始時刻
					Start KotDate `json:"start"`
				} `json:"current"`

				// CurrentFlow 現在の承認フローレベル（１～５）
				CurrentFlow N200OvertimeRequestsCurrentFlow `json:"currentFlow"`

				// Date 対象日
				Date openapi_types.Date `json:"date"`

				// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
				EmployeeKey string `json:"employeeKey"`

				// Flow 承認フロー
				Flow *[]struct {
					// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
					AdministratorKeys []string `json:"administratorKeys"`

					// Level 承認フローレベル（１～５）
					Level N200OvertimeRequestsFlowLevel `json:"level"`
				} `json:"flow,omitempty"`

				// LastModifiedAdministratorKey 最終更新管理者識別キー
				LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

				// Message 申請メッセージ
				Message string `json:"message"`

				// RequestKey 申請識別キー
				RequestKey string `json:"requestKey"`

				// Requested 申請内容
				Requested struct {
					// End 終了時刻
					End KotDate `json:"end"`

					// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
					IsBeforeSchedule bool `json:"isBeforeSchedule"`

					// Start 開始時刻
					Start KotDate `json:"start"`
				} `json:"requested"`

				// RequestedDate 申請日
				RequestedDate openapi_types.Date `json:"requestedDate"`

				// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
				Status N200OvertimeRequestsStatus `json:"status"`
			} `json:"overtimeRequests"`
			Year int `json:"year"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Month            int32 `json:"month"`
			ScheduleRequests []struct {
				// AdminComment 管理者コメント
				AdminComment string `json:"adminComment"`
				Applicant    struct {
					// Key 識別キー（従業員 または 管理者）
					Key string `json:"key"`

					// Type 種別（employee： 従業員　administrator： 管理者)
					Type N200ScheduleRequestsApplicantType `json:"type"`
				} `json:"applicant"`
				Current struct {
					// BreakSchedule 休憩予定時間（分）
					BreakSchedule int32 `json:"breakSchedule"`

					// ClockInSchedule 出勤予定時間
					ClockInSchedule KotDate `json:"clockInSchedule"`

					// ClockOutSchedule 退勤予定時間
					ClockOutSchedule KotDate `json:"clockOutSchedule"`

					// HolidaysObtained 休暇取得
					HolidaysObtained struct {
						FulltimeHoliday struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// Name 休暇区分名
							Name string `json:"name"`
						} `json:"fulltimeHoliday"`
						HalfdayHolidays []struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// Name 休暇区分名
							Name string `json:"name"`

							// TypeName 半休種別名
							TypeName string `json:"typeName"`
						} `json:"halfdayHolidays"`
						HourHolidays []struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// End 休暇終了予定
							End KotDate `json:"end"`

							// Minutes 休暇取得時間
							Minutes int32 `json:"minutes"`

							// Name 休暇区分名
							Name string `json:"name"`

							// Start 休暇開始予定
							Start KotDate `json:"start"`
						} `json:"hourHolidays"`
					} `json:"holidaysObtained"`

					// OvertimeUpperLimit 残業上限時間（分）
					OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

					// ScheduleTypeName スケジュール種別
					ScheduleTypeName string `json:"scheduleTypeName"`

					// StartEndBreakSchedule 休憩開始終了予定
					StartEndBreakSchedule []struct {
						// End 休憩終了予定
						End KotDate `json:"end"`

						// Start 休憩開始予定
						Start KotDate `json:"start"`
					} `json:"startEndBreakSchedule"`

					// SubstitutionClockInName 振替出勤
					SubstitutionClockInName string `json:"substitutionClockInName"`

					// WorkDayTypeName 勤務日種別名
					WorkDayTypeName string `json:"workDayTypeName"`

					// WorkPlaceDivisionCode 出勤先所属コード
					WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

					// WorkPlaceDivisionName 出勤先所属名
					WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
				} `json:"current"`

				// CurrentFlow 現在の承認フローレベル（１～５）
				CurrentFlow N200ScheduleRequestsCurrentFlow `json:"currentFlow"`

				// Date 対象日
				Date openapi_types.Date `json:"date"`

				// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
				EmployeeKey string `json:"employeeKey"`

				// Flow 承認フロー
				Flow *[]struct {
					// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
					AdministratorKeys []string `json:"administratorKeys"`

					// Level 承認フローレベル（１～５）
					Level N200ScheduleRequestsFlowLevel `json:"level"`
				} `json:"flow,omitempty"`

				// LastModifiedAdministratorKey 最終更新管理者識別キー
				LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

				// Message 申請メッセージ
				Message string `json:"message"`

				// Note 備考
				Note *string `json:"note,omitempty"`

				// RequestKey 申請識別キー
				RequestKey string `json:"requestKey"`
				Requested  struct {
					// BreakSchedule 休憩予定時間（分）
					BreakSchedule int32 `json:"breakSchedule"`

					// ClockInSchedule 出勤予定時間
					ClockInSchedule KotDate `json:"clockInSchedule"`

					// ClockOutSchedule 退勤予定時間
					ClockOutSchedule KotDate `json:"clockOutSchedule"`

					// HolidaysObtained 休暇取得
					HolidaysObtained struct {
						FulltimeHoliday struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// Name 休暇区分名
							Name string `json:"name"`
						} `json:"fulltimeHoliday"`
						HalfdayHolidays []struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// Name 休暇区分名
							Name string `json:"name"`

							// TypeName 半休種別名
							TypeName string `json:"typeName"`
						} `json:"halfdayHolidays"`
						HourHolidays []struct {
							// Code 休暇区分コード
							Code int `json:"code"`

							// End 休暇終了予定
							End KotDate `json:"end"`

							// Minutes 休暇取得時間
							Minutes int32 `json:"minutes"`

							// Name 休暇区分名
							Name string `json:"name"`

							// Start 休暇開始予定
							Start KotDate `json:"start"`
						} `json:"hourHolidays"`
					} `json:"holidaysObtained"`

					// OvertimeUpperLimit 残業上限時間（分）
					OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

					// ScheduleTypeName スケジュール種別
					ScheduleTypeName string `json:"scheduleTypeName"`

					// StartEndBreakSchedule 休憩開始終了予定
					StartEndBreakSchedule []struct {
						// End 休憩終了予定
						End KotDate `json:"end"`

						// Start 休憩開始予定
						Start KotDate `json:"start"`
					} `json:"startEndBreakSchedule"`

					// SubstitutionClockInName 振替出勤
					SubstitutionClockInName string `json:"substitutionClockInName"`

					// WorkDayTypeName 勤務日種別名
					WorkDayTypeName string `json:"workDayTypeName"`

					// WorkPlaceDivisionCode 出勤先所属コード
					WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

					// WorkPlaceDivisionName 出勤先所属名
					WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
				} `json:"requested"`

				// RequestedDate 申請日
				RequestedDate openapi_types.Date `json:"requestedDate"`

				// SchedulePatternCode スケジュールパターンコード
				SchedulePatternCode *string `json:"schedulePatternCode,omitempty"`

				// SchedulePatternName スケジュールパターン名
				SchedulePatternName *string `json:"schedulePatternName,omitempty"`

				// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
				Status N200ScheduleRequestsStatus `json:"status"`

				// WorkFixedEnd 勤務終了刻限
				WorkFixedEnd *KotDate `json:"workFixedEnd,omitempty"`

				// WorkFixedStart 勤務開始刻限
				WorkFixedStart *KotDate `json:"workFixedStart,omitempty"`
			} `json:"scheduleRequests"`
			Year int32 `json:"year"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSuspendAccessTokenResponse parses an HTTP response from a SuspendAccessTokenWithResponse call
func ParseSuspendAccessTokenResponse(rsp *http.Response) (*SuspendAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshAccessTokenResponse parses an HTTP response from a RefreshAccessTokenWithResponse call
func ParseRefreshAccessTokenResponse(rsp *http.Response) (*RefreshAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Token refreshed access token
			Token string `json:"token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetAccessTokenAvailabilityResponse parses an HTTP response from a GetAccessTokenAvailabilityWithResponse call
func ParseGetAccessTokenAvailabilityResponse(rsp *http.Response) (*GetAccessTokenAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessTokenAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Available bool `json:"available"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkingTypesResponse parses an HTTP response from a GetWorkingTypesWithResponse call
func ParseGetWorkingTypesResponse(rsp *http.Response) (*GetWorkingTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkingTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkingTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/w8AAP//vk/FLL3dAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
