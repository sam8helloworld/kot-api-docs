// Package kotclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package kotclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for GetCompanySettingsDecimalTreatType.
const (
	Round     GetCompanySettingsDecimalTreatType = "round"
	RoundDown GetCompanySettingsDecimalTreatType = "roundDown"
	RoundUp   GetCompanySettingsDecimalTreatType = "roundUp"
)

// Defines values for GetCompanySettingsTimeDisplayFormat.
const (
	Decimal     GetCompanySettingsTimeDisplayFormat = "decimal"
	Sexagesimal GetCompanySettingsTimeDisplayFormat = "sexagesimal"
)

// Defines values for GetEmployeeGender.
const (
	GetEmployeeGenderFemale GetEmployeeGender = "female"
	GetEmployeeGenderMale   GetEmployeeGender = "male"
)

// Defines values for GetEmployeesItemGender.
const (
	GetEmployeesItemGenderFemale GetEmployeesItemGender = "female"
	GetEmployeesItemGenderMale   GetEmployeesItemGender = "male"
)

// Defines values for GetSchedulesScheduleRequestsApplicantType.
const (
	GetSchedulesScheduleRequestsApplicantTypeAdministrator GetSchedulesScheduleRequestsApplicantType = "administrator"
	GetSchedulesScheduleRequestsApplicantTypeEmployee      GetSchedulesScheduleRequestsApplicantType = "employee"
)

// Defines values for GetSchedulesScheduleRequestsCurrentFlow.
const (
	GetSchedulesScheduleRequestsCurrentFlowN1 GetSchedulesScheduleRequestsCurrentFlow = 1
	GetSchedulesScheduleRequestsCurrentFlowN2 GetSchedulesScheduleRequestsCurrentFlow = 2
	GetSchedulesScheduleRequestsCurrentFlowN3 GetSchedulesScheduleRequestsCurrentFlow = 3
	GetSchedulesScheduleRequestsCurrentFlowN4 GetSchedulesScheduleRequestsCurrentFlow = 4
	GetSchedulesScheduleRequestsCurrentFlowN5 GetSchedulesScheduleRequestsCurrentFlow = 5
)

// Defines values for GetSchedulesScheduleRequestsFlowLevel.
const (
	GetSchedulesScheduleRequestsFlowLevelN1 GetSchedulesScheduleRequestsFlowLevel = 1
	GetSchedulesScheduleRequestsFlowLevelN2 GetSchedulesScheduleRequestsFlowLevel = 2
	GetSchedulesScheduleRequestsFlowLevelN3 GetSchedulesScheduleRequestsFlowLevel = 3
	GetSchedulesScheduleRequestsFlowLevelN4 GetSchedulesScheduleRequestsFlowLevel = 4
	GetSchedulesScheduleRequestsFlowLevelN5 GetSchedulesScheduleRequestsFlowLevel = 5
)

// Defines values for GetSchedulesScheduleRequestsStatus.
const (
	GetSchedulesScheduleRequestsStatusApplying GetSchedulesScheduleRequestsStatus = "applying"
	GetSchedulesScheduleRequestsStatusApproved GetSchedulesScheduleRequestsStatus = "approved"
	GetSchedulesScheduleRequestsStatusRejected GetSchedulesScheduleRequestsStatus = "rejected"
)

// Defines values for RegisterEmployeeGender.
const (
	RegisterEmployeeGenderFemale RegisterEmployeeGender = "female"
	RegisterEmployeeGenderMale   RegisterEmployeeGender = "male"
)

// Defines values for UpdateEmployeeGender.
const (
	UpdateEmployeeGenderFemale UpdateEmployeeGender = "female"
	UpdateEmployeeGenderMale   UpdateEmployeeGender = "male"
)

// Defines values for DailyWorkingCurrentDateEmployeeGender.
const (
	DailyWorkingCurrentDateEmployeeGenderFemale     DailyWorkingCurrentDateEmployeeGender = "female"
	DailyWorkingCurrentDateEmployeeGenderMale       DailyWorkingCurrentDateEmployeeGender = "male"
	DailyWorkingCurrentDateEmployeeGenderNoSelected DailyWorkingCurrentDateEmployeeGender = "no_selected"
)

// Defines values for DailyWorkingCustomDailyWorkingCalculationUnitCode.
const (
	DailyWorkingCustomDailyWorkingCalculationUnitCodeN1 DailyWorkingCustomDailyWorkingCalculationUnitCode = 1
	DailyWorkingCustomDailyWorkingCalculationUnitCodeN2 DailyWorkingCustomDailyWorkingCalculationUnitCode = 2
	DailyWorkingCustomDailyWorkingCalculationUnitCodeN4 DailyWorkingCustomDailyWorkingCalculationUnitCode = 4
)

// Defines values for DailyWorkingResponseAutoBreakOff.
const (
	DailyWorkingResponseAutoBreakOffN1 DailyWorkingResponseAutoBreakOff = 1
	DailyWorkingResponseAutoBreakOffN2 DailyWorkingResponseAutoBreakOff = 2
	DailyWorkingResponseAutoBreakOffN3 DailyWorkingResponseAutoBreakOff = 3
)

// Defines values for DailyWorkingTimerecordCode.
const (
	DailyWorkingTimerecordCodeN1 DailyWorkingTimerecordCode = "1"
	DailyWorkingTimerecordCodeN2 DailyWorkingTimerecordCode = "2"
	DailyWorkingTimerecordCodeN3 DailyWorkingTimerecordCode = "3"
	DailyWorkingTimerecordCodeN4 DailyWorkingTimerecordCode = "4"
	DailyWorkingTimerecordCodeN7 DailyWorkingTimerecordCode = "7"
	DailyWorkingTimerecordCodeN8 DailyWorkingTimerecordCode = "8"
)

// Defines values for DailyWorkingTimerecordRequestCode.
const (
	DailyWorkingTimerecordRequestCodeN1 DailyWorkingTimerecordRequestCode = "1"
	DailyWorkingTimerecordRequestCodeN2 DailyWorkingTimerecordRequestCode = "2"
	DailyWorkingTimerecordRequestCodeN3 DailyWorkingTimerecordRequestCode = "3"
	DailyWorkingTimerecordRequestCodeN4 DailyWorkingTimerecordRequestCode = "4"
	DailyWorkingTimerecordRequestCodeN7 DailyWorkingTimerecordRequestCode = "7"
	DailyWorkingTimerecordRequestCodeN8 DailyWorkingTimerecordRequestCode = "8"
)

// Defines values for EmployeeRequestGender.
const (
	EmployeeRequestGenderFemale EmployeeRequestGender = "female"
	EmployeeRequestGenderMale   EmployeeRequestGender = "male"
)

// Defines values for MonthlyWorkingCurrentDateEmployeeGender.
const (
	MonthlyWorkingCurrentDateEmployeeGenderFemale     MonthlyWorkingCurrentDateEmployeeGender = "female"
	MonthlyWorkingCurrentDateEmployeeGenderMale       MonthlyWorkingCurrentDateEmployeeGender = "male"
	MonthlyWorkingCurrentDateEmployeeGenderNoSelected MonthlyWorkingCurrentDateEmployeeGender = "no_selected"
)

// Defines values for MonthlyWorkingHolidayObtainedCode.
const (
	MonthlyWorkingHolidayObtainedCodeN1 MonthlyWorkingHolidayObtainedCode = 1
	MonthlyWorkingHolidayObtainedCodeN2 MonthlyWorkingHolidayObtainedCode = 2
)

// Defines values for MonthlyWorkingHolidayRemainedHolidayRemainedCode.
const (
	MonthlyWorkingHolidayRemainedHolidayRemainedCodeN1 MonthlyWorkingHolidayRemainedHolidayRemainedCode = 1
	MonthlyWorkingHolidayRemainedHolidayRemainedCodeN2 MonthlyWorkingHolidayRemainedHolidayRemainedCode = 2
)

// Defines values for RequestFlowLevel.
const (
	RequestFlowLevelN1 RequestFlowLevel = 1
	RequestFlowLevelN2 RequestFlowLevel = 2
	RequestFlowLevelN3 RequestFlowLevel = 3
	RequestFlowLevelN4 RequestFlowLevel = 4
	RequestFlowLevelN5 RequestFlowLevel = 5
)

// Defines values for RequestOvertimeApplicantType.
const (
	RequestOvertimeApplicantTypeAdministrator RequestOvertimeApplicantType = "administrator"
	RequestOvertimeApplicantTypeEmployee      RequestOvertimeApplicantType = "employee"
)

// Defines values for RequestOvertimeResponseCurrentFlow.
const (
	RequestOvertimeResponseCurrentFlowN1 RequestOvertimeResponseCurrentFlow = 1
	RequestOvertimeResponseCurrentFlowN2 RequestOvertimeResponseCurrentFlow = 2
	RequestOvertimeResponseCurrentFlowN3 RequestOvertimeResponseCurrentFlow = 3
	RequestOvertimeResponseCurrentFlowN4 RequestOvertimeResponseCurrentFlow = 4
	RequestOvertimeResponseCurrentFlowN5 RequestOvertimeResponseCurrentFlow = 5
)

// Defines values for RequestOvertimeResponseStatus.
const (
	RequestOvertimeResponseStatusApplying RequestOvertimeResponseStatus = "applying"
	RequestOvertimeResponseStatusApproved RequestOvertimeResponseStatus = "approved"
	RequestOvertimeResponseStatusRejected RequestOvertimeResponseStatus = "rejected"
)

// Defines values for YearlyWorkingCurrentDateEmployeeGender.
const (
	YearlyWorkingCurrentDateEmployeeGenderFemale     YearlyWorkingCurrentDateEmployeeGender = "female"
	YearlyWorkingCurrentDateEmployeeGenderMale       YearlyWorkingCurrentDateEmployeeGender = "male"
	YearlyWorkingCurrentDateEmployeeGenderNoSelected YearlyWorkingCurrentDateEmployeeGender = "no_selected"
)

// Defines values for GetAdministratorsParamsAdditionalFields.
const (
	GetAdministratorsParamsAdditionalFieldsAssociatedEmployees GetAdministratorsParamsAdditionalFields = "associatedEmployees"
	GetAdministratorsParamsAdditionalFieldsEmailAddresses      GetAdministratorsParamsAdditionalFields = "emailAddresses"
)

// Defines values for GetDailyWorkingsParamsAdditionalFields.
const (
	GetDailyWorkingsParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingsParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingCostsParamsAdditionalFields.
const (
	GetDailyWorkingCostsParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingCostsParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingCostParamsAdditionalFields.
const (
	GetDailyWorkingCostParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingCostParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingTimerecordsParamsAdditionalFields.
const (
	GetDailyWorkingTimerecordsParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingTimerecordsParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingTimerecordParamsAdditionalFields.
const (
	GetDailyWorkingTimerecordParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingTimerecordParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetDailyWorkingParamsAdditionalFields.
const (
	GetDailyWorkingParamsAdditionalFieldsCurrentDateEmployee GetDailyWorkingParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetEmployeeGroupsParamsAdditionalFields.
const (
	Category GetEmployeeGroupsParamsAdditionalFields = "category"
)

// Defines values for GetEmployeesParamsAdditionalFields.
const (
	GetEmployeesParamsAdditionalFieldsAllDayRegardingWorkInMinute GetEmployeesParamsAdditionalFields = "allDayRegardingWorkInMinute"
	GetEmployeesParamsAdditionalFieldsBirthDate                   GetEmployeesParamsAdditionalFields = "birthDate"
	GetEmployeesParamsAdditionalFieldsEmailAddresses              GetEmployeesParamsAdditionalFields = "emailAddresses"
	GetEmployeesParamsAdditionalFieldsFirstNamePhonetics          GetEmployeesParamsAdditionalFields = "firstNamePhonetics"
	GetEmployeesParamsAdditionalFieldsHiredDate                   GetEmployeesParamsAdditionalFields = "hiredDate"
	GetEmployeesParamsAdditionalFieldsLastNamePhonetics           GetEmployeesParamsAdditionalFields = "lastNamePhonetics"
	GetEmployeesParamsAdditionalFieldsResignationDate             GetEmployeesParamsAdditionalFields = "resignationDate"
)

// Defines values for GetEmployeeParamsAdditionalFields.
const (
	AllDayRegardingWorkInMinute GetEmployeeParamsAdditionalFields = "allDayRegardingWorkInMinute"
	BirthDate                   GetEmployeeParamsAdditionalFields = "birthDate"
	EmailAddresses              GetEmployeeParamsAdditionalFields = "emailAddresses"
	FirstNamePhonetics          GetEmployeeParamsAdditionalFields = "firstNamePhonetics"
	HiredDate                   GetEmployeeParamsAdditionalFields = "hiredDate"
	LastNamePhonetics           GetEmployeeParamsAdditionalFields = "lastNamePhonetics"
	ResignationDate             GetEmployeeParamsAdditionalFields = "resignationDate"
)

// Defines values for GetMonthlyWorkingCostParamsAdditionalFields.
const (
	GetMonthlyWorkingCostParamsAdditionalFieldsCurrentDateEmployee GetMonthlyWorkingCostParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetMonthlyWorkingHolidayRemainedParamsAdditionalFields.
const (
	GetMonthlyWorkingHolidayRemainedParamsAdditionalFieldsCurrentDateEmployee GetMonthlyWorkingHolidayRemainedParamsAdditionalFields = "currentDateEmployee"
)

// Defines values for GetMonthlyWorkingParamsAdditionalFields.
const (
	GetMonthlyWorkingParamsAdditionalFieldsCurrentDateEmployee GetMonthlyWorkingParamsAdditionalFields = "currentDateEmployee"
	GetMonthlyWorkingParamsAdditionalFieldsIsConfirmation      GetMonthlyWorkingParamsAdditionalFields = "isConfirmation"
	GetMonthlyWorkingParamsAdditionalFieldsVariationalWork     GetMonthlyWorkingParamsAdditionalFields = "variationalWork"
	GetMonthlyWorkingParamsAdditionalFieldsWeeklyWork          GetMonthlyWorkingParamsAdditionalFields = "weeklyWork"
)

// Defines values for GetOvertimeParamsAdditionalFields.
const (
	GetOvertimeParamsAdditionalFieldsFlow                GetOvertimeParamsAdditionalFields = "flow"
	GetOvertimeParamsAdditionalFieldsNote                GetOvertimeParamsAdditionalFields = "note"
	GetOvertimeParamsAdditionalFieldsSchedulePatternCode GetOvertimeParamsAdditionalFields = "schedulePatternCode"
	GetOvertimeParamsAdditionalFieldsSchedulePatternName GetOvertimeParamsAdditionalFields = "schedulePatternName"
	GetOvertimeParamsAdditionalFieldsWorkFixedEnd        GetOvertimeParamsAdditionalFields = "workFixedEnd"
	GetOvertimeParamsAdditionalFieldsWorkFixedStart      GetOvertimeParamsAdditionalFields = "workFixedStart"
)

// Defines values for GetSchedulesParamsAdditionalFields.
const (
	GetSchedulesParamsAdditionalFieldsFlow                GetSchedulesParamsAdditionalFields = "flow"
	GetSchedulesParamsAdditionalFieldsNote                GetSchedulesParamsAdditionalFields = "note"
	GetSchedulesParamsAdditionalFieldsSchedulePatternCode GetSchedulesParamsAdditionalFields = "schedulePatternCode"
	GetSchedulesParamsAdditionalFieldsSchedulePatternName GetSchedulesParamsAdditionalFields = "schedulePatternName"
	GetSchedulesParamsAdditionalFieldsWorkFixedEnd        GetSchedulesParamsAdditionalFields = "workFixedEnd"
	GetSchedulesParamsAdditionalFieldsWorkFixedStart      GetSchedulesParamsAdditionalFields = "workFixedStart"
)

// Defines values for GetYearlyWorkingHolidayParamsAdditionalFields.
const (
	GetYearlyWorkingHolidayParamsAdditionalFieldsCurrentDateEmployee GetYearlyWorkingHolidayParamsAdditionalFields = "currentDateEmployee"
)

// GetAccessTokenAvailability defines model for GetAccessTokenAvailability.
type GetAccessTokenAvailability struct {
	Available bool `json:"available"`
}

// GetAdministrators defines model for GetAdministrators.
type GetAdministrators = []GetAdministratorsItem

// GetAdministratorsAssociatedEmployee 割当従業員
type GetAdministratorsAssociatedEmployee struct {
	// Code 従業員コード
	Code string `json:"code"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`
}

// GetAdministratorsItem defines model for GetAdministrators_item.
type GetAdministratorsItem struct {
	AssociatedEmployees *[]GetAdministratorsAssociatedEmployee `json:"associatedEmployees,omitempty"`

	// Code 管理者コード
	Code string `json:"code"`

	// EmailAddresses メールアドレス
	EmailAddresses *openapi_types.Email `json:"emailAddresses,omitempty"`

	// Key 管理者識別キー（管理者コードが変更されても不変）
	Key string `json:"key"`

	// Name 管理者名
	Name string `json:"name"`
}

// GetCompany defines model for GetCompany.
type GetCompany struct {
	// BusinessYearStartDate 事業年度開始日
	BusinessYearStartDate string `json:"businessYearStartDate"`

	// Code 企業コード
	Code string `json:"code"`

	// Host ホスト名
	Host string `json:"host"`

	// Key 企業識別キー
	Key string `json:"key"`

	// Name 企業名
	Name string `json:"name"`

	// Settings 企業設定情報
	Settings GetCompanySettings `json:"settings"`
}

// GetCompanySettings 企業設定情報
type GetCompanySettings struct {
	// DecimalTreatType 10進表示の小数第3位の扱い（roundDown： 切下げ　roundUp： 切上げ　round： 四捨五入）
	DecimalTreatType GetCompanySettingsDecimalTreatType `json:"decimalTreatType"`

	// TimeDisplayFormat 表示形式（decimal： 10進法　sexagesimal： 60進法）
	TimeDisplayFormat GetCompanySettingsTimeDisplayFormat `json:"timeDisplayFormat"`
}

// GetCompanySettingsDecimalTreatType 10進表示の小数第3位の扱い（roundDown： 切下げ　roundUp： 切上げ　round： 四捨五入）
type GetCompanySettingsDecimalTreatType string

// GetCompanySettingsTimeDisplayFormat 表示形式（decimal： 10進法　sexagesimal： 60進法）
type GetCompanySettingsTimeDisplayFormat string

// GetDailyWorking defines model for GetDailyWorking.
type GetDailyWorking struct {
	DailyWorkings []DailyWorkingResponse `json:"dailyWorkings"`
	Date          openapi_types.Date     `json:"date"`
}

// GetDailyWorkingCost defines model for GetDailyWorkingCost.
type GetDailyWorkingCost struct {
	DailyWorkings []DailyWorkingCostResponse `json:"dailyWorkings"`
	Date          openapi_types.Date         `json:"date"`
}

// GetDailyWorkingCosts defines model for GetDailyWorkingCosts.
type GetDailyWorkingCosts = []struct {
	DailyWorkings []DailyWorkingCostResponse `json:"dailyWorkings"`
	Date          openapi_types.Date         `json:"date"`
}

// GetDailyWorkingTimerecords defines model for GetDailyWorkingTimerecords.
type GetDailyWorkingTimerecords = []struct {
	DailyWorkings []DailyWorkingTimerecordResponse `json:"dailyWorkings"`
	Date          openapi_types.Date               `json:"date"`
}

// GetDailyWorkings defines model for GetDailyWorkings.
type GetDailyWorkings = []struct {
	DailyWorkings []DailyWorkingResponse `json:"dailyWorkings"`
	Date          openapi_types.Date     `json:"date"`
}

// GetDivisions defines model for GetDivisions.
type GetDivisions = []DivisionResponse

// GetEmployee defines model for GetEmployee.
type GetEmployee struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender GetEmployeeGender `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// GetEmployeeGender 性別（male： 男性　female： 女性）
type GetEmployeeGender string

// GetEmployeeGroups defines model for GetEmployeeGroups.
type GetEmployeeGroups = []GetEmployeeGroupsItem

// GetEmployeeGroupsItem defines model for GetEmployeeGroups_item.
type GetEmployeeGroupsItem struct {
	// Category 従業員グループカテゴリ
	Category *GetEmployeeGroupsItemCategory `json:"category,omitempty"`

	// Code 従業員グループコード
	Code string `json:"code"`

	// Name 従業員グループ名
	Name string `json:"name"`
}

// GetEmployeeGroupsItemCategory 従業員グループカテゴリ
type GetEmployeeGroupsItemCategory struct {
	// Code 従業員グループカテゴリコード
	Code string `json:"code"`

	// Name 従業員グループカテゴリ名
	Name string `json:"name"`
}

// GetEmployees defines model for GetEmployees.
type GetEmployees = []GetEmployeesItem

// GetEmployeesItem defines model for GetEmployees_item.
type GetEmployeesItem struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender GetEmployeesItemGender `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// GetEmployeesItemGender 性別（male： 男性　female： 女性）
type GetEmployeesItemGender string

// GetMonthlyWorking defines model for GetMonthlyWorking.
type GetMonthlyWorking = []struct {
	// AbsentdayCount 欠勤日数
	AbsentdayCount int `json:"absentdayCount"`

	// Assigned 所定時間（分）
	Assigned int `json:"assigned"`

	// Bind 拘束時間（分）
	Bind int `json:"bind"`

	// BreakSum 休憩時間（分）
	BreakSum int `json:"breakSum"`

	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *MonthlyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// CustomMonthlyWorkings 月別カスタム勤怠項目
	CustomMonthlyWorkings []MonthlyWorkingCustomMonthlyWorking `json:"customMonthlyWorkings"`

	// EarlyLeave 早退時間（分）
	EarlyLeave int `json:"earlyLeave"`

	// EarlyLeaveCount 早退回数
	EarlyLeaveCount int `json:"earlyLeaveCount"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// EndDate 集計終了日
	EndDate openapi_types.Date `json:"endDate"`

	// GeneralHolidayWork 法定外休日労働
	GeneralHolidayWork MonthlyWorkingGeneralHolidayWork `json:"generalHolidayWork"`

	// HolidayWork 休日労働
	HolidayWork MonthlyWorkingHolidayWork `json:"holidayWork"`

	// HolidaysObtained 休暇取得
	HolidaysObtained []MonthlyWorkingHolidayObtained `json:"holidaysObtained"`

	// IntervalShortageCount インターバル不足回数
	IntervalShortageCount int `json:"intervalShortageCount"`

	// IsClosing 締め状況
	IsClosing bool `json:"isClosing"`

	// IsConfirmation 確認状況
	IsConfirmation *bool `json:"isConfirmation,omitempty"`

	// Late 遅刻時間（分）
	Late int `json:"late"`

	// LateCount 遅刻回数
	LateCount int `json:"lateCount"`

	// LegalHolidayWork 法定休日労働
	LegalHolidayWork MonthlyWorkingLegalHolidayWork `json:"legalHolidayWork"`

	// Month 月
	Month int `json:"month"`

	// Night 深夜労働時間（分）
	Night int `json:"night"`

	// NightOvertime 深夜残業時間（分）
	NightOvertime int `json:"nightOvertime"`

	// NightUnassigned 深夜所定外時間（分）
	NightUnassigned int `json:"nightUnassigned"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`

	// PremiumWork 割増労働
	PremiumWork MonthlyWorkingPremiumWork `json:"premiumWork"`

	// Regarding 休暇みなし時間（分）
	Regarding int `json:"regarding"`

	// StartDate 集計開始日
	StartDate openapi_types.Date `json:"startDate"`

	// Unassigned 所定外時間（分）
	Unassigned int `json:"unassigned"`

	// VariationalWork 変形労働
	VariationalWork *MonthlyWorkingVariationalWork `json:"variationalWork,omitempty"`

	// WeekdayWorkingCount 平日勤務回数
	WeekdayWorkingCount int `json:"weekdayWorkingCount"`

	// WeekdayWorkingdayCount 平日勤務日数
	WeekdayWorkingdayCount int `json:"weekdayWorkingdayCount"`

	// WeeklyWork 週の残業時間
	WeeklyWork *MonthlyWorkingWeeklyWork `json:"weeklyWork,omitempty"`

	// WorkingCount 総勤務回数
	WorkingCount int `json:"workingCount"`

	// WorkingDayCount 総勤務日数
	WorkingDayCount int `json:"workingDayCount"`

	// Year 年
	Year int `json:"year"`
}

// GetMonthlyWorkingHolidayRemained defines model for GetMonthlyWorkingHolidayRemained.
type GetMonthlyWorkingHolidayRemained = []MonthlyWorkingHolidayRemainedResponse

// GetOvertime defines model for GetOvertime.
type GetOvertime struct {
	Month            int                       `json:"month"`
	OvertimeRequests []RequestOvertimeResponse `json:"overtimeRequests"`
	Year             int                       `json:"year"`
}

// GetSchedules defines model for GetSchedules.
type GetSchedules struct {
	Month            int32 `json:"month"`
	ScheduleRequests []struct {
		// AdminComment 管理者コメント
		AdminComment string `json:"adminComment"`
		Applicant    struct {
			// Key 識別キー（従業員 または 管理者）
			Key string `json:"key"`

			// Type 種別（employee： 従業員　administrator： 管理者)
			Type GetSchedulesScheduleRequestsApplicantType `json:"type"`
		} `json:"applicant"`
		Current struct {
			// BreakSchedule 休憩予定時間（分）
			BreakSchedule int32 `json:"breakSchedule"`

			// ClockInSchedule 出勤予定時間
			ClockInSchedule KotDate `json:"clockInSchedule"`

			// ClockOutSchedule 退勤予定時間
			ClockOutSchedule KotDate `json:"clockOutSchedule"`

			// HolidaysObtained 休暇取得
			HolidaysObtained struct {
				FulltimeHoliday struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// Name 休暇区分名
					Name string `json:"name"`
				} `json:"fulltimeHoliday"`
				HalfdayHolidays []struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// Name 休暇区分名
					Name string `json:"name"`

					// TypeName 半休種別名
					TypeName string `json:"typeName"`
				} `json:"halfdayHolidays"`
				HourHolidays []struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// End 休暇終了予定
					End KotDate `json:"end"`

					// Minutes 休暇取得時間
					Minutes int32 `json:"minutes"`

					// Name 休暇区分名
					Name string `json:"name"`

					// Start 休暇開始予定
					Start KotDate `json:"start"`
				} `json:"hourHolidays"`
			} `json:"holidaysObtained"`

			// OvertimeUpperLimit 残業上限時間（分）
			OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

			// ScheduleTypeName スケジュール種別
			ScheduleTypeName string `json:"scheduleTypeName"`

			// StartEndBreakSchedule 休憩開始終了予定
			StartEndBreakSchedule []struct {
				// End 休憩終了予定
				End KotDate `json:"end"`

				// Start 休憩開始予定
				Start KotDate `json:"start"`
			} `json:"startEndBreakSchedule"`

			// SubstitutionClockInName 振替出勤
			SubstitutionClockInName string `json:"substitutionClockInName"`

			// WorkDayTypeName 勤務日種別名
			WorkDayTypeName string `json:"workDayTypeName"`

			// WorkPlaceDivisionCode 出勤先所属コード
			WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

			// WorkPlaceDivisionName 出勤先所属名
			WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
		} `json:"current"`

		// CurrentFlow 現在の承認フローレベル（１～５）
		CurrentFlow GetSchedulesScheduleRequestsCurrentFlow `json:"currentFlow"`

		// Date 対象日
		Date openapi_types.Date `json:"date"`

		// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
		EmployeeKey string `json:"employeeKey"`

		// Flow 承認フロー
		Flow *[]struct {
			// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
			AdministratorKeys []string `json:"administratorKeys"`

			// Level 承認フローレベル（１～５）
			Level GetSchedulesScheduleRequestsFlowLevel `json:"level"`
		} `json:"flow,omitempty"`

		// LastModifiedAdministratorKey 最終更新管理者識別キー
		LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

		// Message 申請メッセージ
		Message string `json:"message"`

		// Note 備考
		Note *string `json:"note,omitempty"`

		// RequestKey 申請識別キー
		RequestKey string `json:"requestKey"`
		Requested  struct {
			// BreakSchedule 休憩予定時間（分）
			BreakSchedule int32 `json:"breakSchedule"`

			// ClockInSchedule 出勤予定時間
			ClockInSchedule KotDate `json:"clockInSchedule"`

			// ClockOutSchedule 退勤予定時間
			ClockOutSchedule KotDate `json:"clockOutSchedule"`

			// HolidaysObtained 休暇取得
			HolidaysObtained struct {
				FulltimeHoliday struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// Name 休暇区分名
					Name string `json:"name"`
				} `json:"fulltimeHoliday"`
				HalfdayHolidays []struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// Name 休暇区分名
					Name string `json:"name"`

					// TypeName 半休種別名
					TypeName string `json:"typeName"`
				} `json:"halfdayHolidays"`
				HourHolidays []struct {
					// Code 休暇区分コード
					Code int `json:"code"`

					// End 休暇終了予定
					End KotDate `json:"end"`

					// Minutes 休暇取得時間
					Minutes int32 `json:"minutes"`

					// Name 休暇区分名
					Name string `json:"name"`

					// Start 休暇開始予定
					Start KotDate `json:"start"`
				} `json:"hourHolidays"`
			} `json:"holidaysObtained"`

			// OvertimeUpperLimit 残業上限時間（分）
			OvertimeUpperLimit *int32 `json:"overtimeUpperLimit,omitempty"`

			// ScheduleTypeName スケジュール種別
			ScheduleTypeName string `json:"scheduleTypeName"`

			// StartEndBreakSchedule 休憩開始終了予定
			StartEndBreakSchedule []struct {
				// End 休憩終了予定
				End KotDate `json:"end"`

				// Start 休憩開始予定
				Start KotDate `json:"start"`
			} `json:"startEndBreakSchedule"`

			// SubstitutionClockInName 振替出勤
			SubstitutionClockInName string `json:"substitutionClockInName"`

			// WorkDayTypeName 勤務日種別名
			WorkDayTypeName string `json:"workDayTypeName"`

			// WorkPlaceDivisionCode 出勤先所属コード
			WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

			// WorkPlaceDivisionName 出勤先所属名
			WorkPlaceDivisionName string `json:"workPlaceDivisionName"`
		} `json:"requested"`

		// RequestedDate 申請日
		RequestedDate openapi_types.Date `json:"requestedDate"`

		// SchedulePatternCode スケジュールパターンコード
		SchedulePatternCode *string `json:"schedulePatternCode,omitempty"`

		// SchedulePatternName スケジュールパターン名
		SchedulePatternName *string `json:"schedulePatternName,omitempty"`

		// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
		Status GetSchedulesScheduleRequestsStatus `json:"status"`

		// WorkFixedEnd 勤務終了刻限
		WorkFixedEnd *KotDate `json:"workFixedEnd,omitempty"`

		// WorkFixedStart 勤務開始刻限
		WorkFixedStart *KotDate `json:"workFixedStart,omitempty"`
	} `json:"scheduleRequests"`
	Year int32 `json:"year"`
}

// GetSchedulesScheduleRequestsApplicantType 種別（employee： 従業員　administrator： 管理者)
type GetSchedulesScheduleRequestsApplicantType string

// GetSchedulesScheduleRequestsCurrentFlow 現在の承認フローレベル（１～５）
type GetSchedulesScheduleRequestsCurrentFlow int32

// GetSchedulesScheduleRequestsFlowLevel 承認フローレベル（１～５）
type GetSchedulesScheduleRequestsFlowLevel int

// GetSchedulesScheduleRequestsStatus 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
type GetSchedulesScheduleRequestsStatus string

// GetYearlyWorkingHoliday defines model for GetYearlyWorkingHoliday.
type GetYearlyWorkingHoliday struct {
	// CloseDate 締日
	CloseDate int `json:"closeDate"`

	// Employees 従業員別の休暇情報
	Employees []YearlyWorkingEmployee `json:"employees"`

	// EndDate 年度終了日
	EndDate openapi_types.Date `json:"endDate"`

	// StartDate 年度開始日
	StartDate openapi_types.Date `json:"startDate"`

	// Year 年度
	Year int `json:"year"`
}

// RefreshAccessToken defines model for RefreshAccessToken.
type RefreshAccessToken struct {
	// Token refreshed access token
	Token string `json:"token"`
}

// RegisterDailyWorkingTimerecord defines model for RegisterDailyWorkingTimerecord.
type RegisterDailyWorkingTimerecord struct {
	// Date 日時
	Date openapi_types.Date `json:"date"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// TimeRecord 打刻
	TimeRecord DailyWorkingTimerecord `json:"timeRecord"`
}

// RegisterEmployee defines model for RegisterEmployee.
type RegisterEmployee struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender RegisterEmployeeGender `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// RegisterEmployeeGender 性別（male： 男性　female： 女性）
type RegisterEmployeeGender string

// UpdateEmployee defines model for UpdateEmployee.
type UpdateEmployee struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []struct {
		// Code 従業員グループコード
		Code string `json:"code"`

		// Name 従業員グループ名
		Name string `json:"name"`
	} `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender UpdateEmployeeGender `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// Key 従業員識別キー（従業員コードが変更されても不変）
	Key string `json:"key"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// UpdateEmployeeGender 性別（male： 男性　female： 女性）
type UpdateEmployeeGender string

// DailyWorkingCostResponse defines model for daily_working_cost_response.
type DailyWorkingCostResponse struct {
	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *DailyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// Date 日時
	Date openapi_types.Date `json:"date"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// LaborCostEstimate 人件費概算
	LaborCostEstimate int `json:"laborCostEstimate"`

	// TransportationExpense 交通費
	TransportationExpense int `json:"transportationExpense"`
}

// DailyWorkingCurrentDateEmployee 今日時点の従業員データ
type DailyWorkingCurrentDateEmployee struct {
	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics string `json:"firstNamePhonetics"`

	// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
	Gender DailyWorkingCurrentDateEmployeeGender `json:"gender"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics string `json:"lastNamePhonetics"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// DailyWorkingCurrentDateEmployeeGender 性別（no_selected： 選択しない　male： 男性　female： 女性）
type DailyWorkingCurrentDateEmployeeGender string

// DailyWorkingCustomDailyWorking defines model for daily_working_custom_daily_working.
type DailyWorkingCustomDailyWorking struct {
	// CalculationResult 計算結果
	CalculationResult int `json:"calculationResult"`

	// CalculationUnitCode 計算単位コード（1： 日数　2： 時間　4： 数値）
	CalculationUnitCode DailyWorkingCustomDailyWorkingCalculationUnitCode `json:"calculationUnitCode"`

	// Code 日別カスタム表示コード
	Code string `json:"code"`

	// Name 日別カスタム表示名
	Name string `json:"name"`
}

// DailyWorkingCustomDailyWorkingCalculationUnitCode 計算単位コード（1： 日数　2： 時間　4： 数値）
type DailyWorkingCustomDailyWorkingCalculationUnitCode int

// DailyWorkingFulltimeHoliday defines model for daily_working_fulltime_holiday.
type DailyWorkingFulltimeHoliday struct {
	// Code 休暇区分コード
	Code int `json:"code"`

	// Name 休暇区分名
	Name string `json:"name"`
}

// DailyWorkingHalfdayHoliday defines model for daily_working_halfday_holiday.
type DailyWorkingHalfdayHoliday struct {
	// Code 休暇区分コード
	Code int `json:"code"`

	// Name 休暇区分名
	Name string `json:"name"`

	// TypeName 半休種別名
	TypeName string `json:"typeName"`
}

// DailyWorkingHolidaysObtained 休暇取得
type DailyWorkingHolidaysObtained struct {
	FulltimeHoliday DailyWorkingFulltimeHoliday  `json:"fulltimeHoliday"`
	HalfdayHolidays []DailyWorkingHalfdayHoliday `json:"halfdayHolidays"`
	HourHolidays    []DailyWorkingHourHoliday    `json:"hourHolidays"`
}

// DailyWorkingHourHoliday defines model for daily_working_hour_holiday.
type DailyWorkingHourHoliday struct {
	// Code 休暇区分コード
	Code int `json:"code"`

	// End 休暇終了時間
	End time.Time `json:"end"`

	// Minutes 休暇取得時間
	Minutes int `json:"minutes"`

	// Name 休暇区分名
	Name string `json:"name"`

	// Start 休暇開始時間
	Start time.Time `json:"start"`
}

// DailyWorkingResponse defines model for daily_working_response.
type DailyWorkingResponse struct {
	// Assigned 所定時間（分）
	Assigned int `json:"assigned"`

	// AutoBreakOff 自動休憩無効（null： 休憩を無効化しない 1：　雇用区分休憩無効　2： スケジュール休憩無効　3： 全ての自動休憩無効）
	AutoBreakOff DailyWorkingResponseAutoBreakOff `json:"autoBreakOff"`

	// BreakTime 休憩時間（分）
	BreakTime int `json:"breakTime"`

	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *DailyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`
	CustomDailyWorkings []DailyWorkingCustomDailyWorking `json:"customDailyWorkings"`

	// Date 日時
	Date openapi_types.Date `json:"date"`

	// DiscretionaryVacation 休暇みなし時間（分）
	DiscretionaryVacation int `json:"discretionaryVacation"`

	// EarlyLeave 早退時間（分）
	EarlyLeave int `json:"earlyLeave"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// HolidaysObtained 休暇取得
	HolidaysObtained DailyWorkingHolidaysObtained `json:"holidaysObtained"`

	// IsClosing 締め状況
	IsClosing bool `json:"isClosing"`

	// IsError エラー勤務状況
	IsError bool `json:"isError"`

	// IsHelp ヘルプ勤務状況
	IsHelp bool `json:"isHelp"`

	// Late 遅刻時間（分）
	Late int `json:"late"`

	// LateNight 深夜時間（分）
	LateNight int `json:"lateNight"`

	// LateNightOvertime 深夜残業時間（分）
	LateNightOvertime int `json:"lateNightOvertime"`

	// LateNightUnassigned 深夜所定外時間（分）
	LateNightUnassigned int `json:"lateNightUnassigned"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`

	// TotalWork 労働合計時間（分）
	TotalWork int `json:"totalWork"`

	// Unassigned 所定外時間（分）
	Unassigned int `json:"unassigned"`

	// WorkPlaceDivisionCode 出勤先所属コード
	WorkPlaceDivisionCode string `json:"workPlaceDivisionCode"`

	// WorkPlaceDivisionName 出勤先所属名
	WorkPlaceDivisionName *string `json:"workPlaceDivisionName,omitempty"`

	// WorkdayTypeName 勤務日種別名
	WorkdayTypeName string `json:"workdayTypeName"`
}

// DailyWorkingResponseAutoBreakOff 自動休憩無効（null： 休憩を無効化しない 1：　雇用区分休憩無効　2： スケジュール休憩無効　3： 全ての自動休憩無効）
type DailyWorkingResponseAutoBreakOff int

// DailyWorkingTimerecord 打刻
type DailyWorkingTimerecord struct {
	// Code 打刻種別コード
	Code DailyWorkingTimerecordCode `json:"code"`

	// CredentialCode (注)レスポンス定義にはこのキーは存在しないが、例にはある
	CredentialCode *int `json:"credentialCode,omitempty"`

	// CredentialName (注)レスポンス定義にはこのキーは存在しないが、例にはある
	CredentialName *string `json:"credentialName,omitempty"`

	// DivisionCode 打刻所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 打刻所属名
	DivisionName string `json:"divisionName"`

	// Latitude 緯度
	Latitude float64 `json:"latitude"`

	// Longitude 経度
	Longitude float64 `json:"longitude"`

	// Name 打刻種別名
	Name string `json:"name"`

	// Time 打刻時間
	Time time.Time `json:"time"`
}

// DailyWorkingTimerecordCode 打刻種別コード
type DailyWorkingTimerecordCode string

// DailyWorkingTimerecordRequest defines model for daily_working_timerecord_request.
type DailyWorkingTimerecordRequest struct {
	// Code 打刻種別コード（1： 出勤　2： 退勤　3： 休憩開始　4： 休憩終了　7： 外出入　8： 外出戻）
	// 省略時は、KING OF TIMEの処理に従って打刻種別を決定します。
	Code *DailyWorkingTimerecordRequestCode `json:"code,omitempty"`

	// Date 勤務日
	// 指定された勤務日に打刻データが紐づきます。
	Date openapi_types.Date `json:"date"`

	// DivisionCode 打刻先所属コード
	// 省略時は、該当従業員が所属している所属を打刻先所属として扱います。
	DivisionCode *string `json:"divisionCode,omitempty"`

	// Latitude 緯度
	Latitude *float64 `json:"latitude,omitempty"`

	// Longitude 経度
	Longitude *float64 `json:"longitude,omitempty"`

	// Time 打刻時間
	Time time.Time `json:"time"`
}

// DailyWorkingTimerecordRequestCode 打刻種別コード（1： 出勤　2： 退勤　3： 休憩開始　4： 休憩終了　7： 外出入　8： 外出戻）
// 省略時は、KING OF TIMEの処理に従って打刻種別を決定します。
type DailyWorkingTimerecordRequestCode string

// DailyWorkingTimerecordResponse defines model for daily_working_timerecord_response.
type DailyWorkingTimerecordResponse struct {
	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *DailyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// Date 日時
	Date openapi_types.Date `json:"date"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// TimeRecord 打刻
	TimeRecord []DailyWorkingTimerecord `json:"timeRecord"`
}

// DivisionResponse defines model for division_response.
type DivisionResponse struct {
	// Code 所属コード
	Code string `json:"code"`

	// DayBorderTime 所属名
	DayBorderTime string `json:"dayBorderTime"`

	// Name 所属名
	Name string `json:"name"`
}

// EmployeeGroup defines model for employee_group.
type EmployeeGroup struct {
	// Code 従業員グループコード
	Code string `json:"code"`

	// Name 従業員グループ名
	Name string `json:"name"`
}

// EmployeeRequest defines model for employee_request.
type EmployeeRequest struct {
	// AllDayRegardingWorkInMinute 日の契約労働時間
	AllDayRegardingWorkInMinute *int `json:"allDayRegardingWorkInMinute,omitempty"`

	// BirthDate 生年月日
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// EmailAddresses メールアドレス
	EmailAddresses *[]openapi_types.Email `json:"emailAddresses,omitempty"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics *string `json:"firstNamePhonetics,omitempty"`

	// Gender 性別（male： 男性　female： 女性）
	Gender EmployeeRequestGender `json:"gender"`

	// HiredDate 入社年月日
	HiredDate *openapi_types.Date `json:"hiredDate,omitempty"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics *string `json:"lastNamePhonetics,omitempty"`

	// ResignationDate 退職年月日
	ResignationDate *openapi_types.Date `json:"resignationDate,omitempty"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`
}

// EmployeeRequestGender 性別（male： 男性　female： 女性）
type EmployeeRequestGender string

// MonthlyWorkingCostResponse defines model for monthly_working_cost_response.
type MonthlyWorkingCostResponse struct {
	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *MonthlyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// EndDate 集計終了日
	EndDate openapi_types.Date `json:"endDate"`

	// LaborCostEstimate 人件費概算
	LaborCostEstimate int `json:"laborCostEstimate"`

	// Month 月
	Month int `json:"month"`

	// StartDate 集計開始日
	StartDate openapi_types.Date `json:"startDate"`

	// TransportationExpense 交通費
	TransportationExpense int `json:"transportationExpense"`

	// Year 年
	Year int `json:"year"`
}

// MonthlyWorkingCurrentDateEmployee 今日時点の従業員データ
type MonthlyWorkingCurrentDateEmployee struct {
	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics string `json:"firstNamePhonetics"`

	// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
	Gender MonthlyWorkingCurrentDateEmployeeGender `json:"gender"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics string `json:"lastNamePhonetics"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// MonthlyWorkingCurrentDateEmployeeGender 性別（no_selected： 選択しない　male： 男性　female： 女性）
type MonthlyWorkingCurrentDateEmployeeGender string

// MonthlyWorkingCustomMonthlyWorking defines model for monthly_working_custom_monthly_working.
type MonthlyWorkingCustomMonthlyWorking struct {
	// CalculationResult 計算結果
	CalculationResult int `json:"calculationResult"`

	// CalculationUnitCode 計算単位コード
	CalculationUnitCode int `json:"calculationUnitCode"`

	// CalculationUnitName 計算単位名
	CalculationUnitName string `json:"calculationUnitName"`

	// Code 月別カスタム表示コード
	Code string `json:"code"`

	// Name 月別カスタム表示名
	Name string `json:"name"`
}

// MonthlyWorkingGeneralHolidayWork 法定外休日労働
type MonthlyWorkingGeneralHolidayWork struct {
	// Count 勤務回数
	Count int `json:"count"`

	// DayCount 勤務日数
	DayCount int `json:"dayCount"`

	// Extra 所定外時間（分）
	Extra int `json:"extra"`

	// Night 深夜労働時間（分）
	Night int `json:"night"`

	// NightExtra 深夜所定外時間（分）
	NightExtra int `json:"nightExtra"`

	// NightOvertime 深夜残業時間（分）
	NightOvertime int `json:"nightOvertime"`

	// Normal 所定労働時間（分）
	Normal int `json:"normal"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`
}

// MonthlyWorkingHolidayObtained defines model for monthly_working_holiday_obtained.
type MonthlyWorkingHolidayObtained struct {
	// Code 休暇区分コード（1 または 2 の休暇はデフォルトで設定されている休暇）
	Code MonthlyWorkingHolidayObtainedCode `json:"code"`

	// DayCount 休暇取得日数
	DayCount int `json:"dayCount"`

	// Minutes 時間休暇取得時間（分）
	Minutes int `json:"minutes"`

	// Name 休暇区分名
	Name string `json:"name"`
}

// MonthlyWorkingHolidayObtainedCode 休暇区分コード（1 または 2 の休暇はデフォルトで設定されている休暇）
type MonthlyWorkingHolidayObtainedCode int

// MonthlyWorkingHolidayRemainedHolidayRemained 残休暇
type MonthlyWorkingHolidayRemainedHolidayRemained struct {
	// Code 休暇区分コード（1 または 2 の休暇はデフォルトで設定されている休暇）
	Code MonthlyWorkingHolidayRemainedHolidayRemainedCode `json:"code"`

	// Day 残休暇日数
	Day int `json:"day"`

	// Minutes 残休暇時間
	Minutes int `json:"minutes"`

	// Name 休暇区分名
	Name string `json:"name"`
}

// MonthlyWorkingHolidayRemainedHolidayRemainedCode 休暇区分コード（1 または 2 の休暇はデフォルトで設定されている休暇）
type MonthlyWorkingHolidayRemainedHolidayRemainedCode int

// MonthlyWorkingHolidayRemainedResponse defines model for monthly_working_holiday_remained_response.
type MonthlyWorkingHolidayRemainedResponse struct {
	// CloseDate 締日
	CloseDate int `json:"closeDate"`

	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *MonthlyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// Date 年月日(残休暇取得時点)
	Date openapi_types.Date `json:"date"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey     string                                         `json:"employeeKey"`
	HolidayRemained []MonthlyWorkingHolidayRemainedHolidayRemained `json:"holidayRemained"`
}

// MonthlyWorkingHolidayWork 休日労働
type MonthlyWorkingHolidayWork struct {
	// Extra 所定外時間（分）
	Extra int `json:"extra"`

	// Night 深夜労働時間（分）
	Night int `json:"night"`

	// NightExtra 深夜所定外時間（分）
	NightExtra int `json:"nightExtra"`

	// NightOvertime 深夜残業時間（分）
	NightOvertime int `json:"nightOvertime"`

	// Normal 所定労働時間（分）
	Normal int `json:"normal"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`
}

// MonthlyWorkingLegalHolidayWork 法定休日労働
type MonthlyWorkingLegalHolidayWork struct {
	// Count 勤務回数
	Count int `json:"count"`

	// DayCount 勤務日数
	DayCount int `json:"dayCount"`

	// Extra 所定外時間（分）
	Extra int `json:"extra"`

	// Night 深夜労働時間（分）
	Night int `json:"night"`

	// NightExtra 深夜所定外時間（分）
	NightExtra int `json:"nightExtra"`

	// NightOvertime 深夜残業時間（分）
	NightOvertime int `json:"nightOvertime"`

	// Normal 所定労働時間（分）
	Normal int `json:"normal"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`
}

// MonthlyWorkingPremiumWork 割増労働
type MonthlyWorkingPremiumWork struct {
	// NightOvertime1 深夜残業時間１（分）
	NightOvertime1 int `json:"nightOvertime1"`

	// NightOvertime2 深夜残業時間２（分）
	NightOvertime2 int `json:"nightOvertime2"`

	// Overtime1 残業時間１（分）
	Overtime1 int `json:"overtime1"`

	// Overtime2 残業時間２（分）
	Overtime2 int `json:"overtime2"`
}

// MonthlyWorkingVariationalWork 変形労働
type MonthlyWorkingVariationalWork struct {
	// MonthlyGeneralHolidayNightOvertime 月の法定外休日深夜残業時間（分）
	MonthlyGeneralHolidayNightOvertime int `json:"monthlyGeneralHolidayNightOvertime"`

	// MonthlyGeneralHolidayOvertime 月の法定外休日残業時間（分）
	MonthlyGeneralHolidayOvertime int `json:"monthlyGeneralHolidayOvertime"`

	// MonthlyLegalHolidayNightOvertime 月の法定休日深夜残業時間（分）
	MonthlyLegalHolidayNightOvertime int `json:"monthlyLegalHolidayNightOvertime"`

	// MonthlyLegalHolidayOvertime 月の法定休日残業時間（分）
	MonthlyLegalHolidayOvertime int `json:"monthlyLegalHolidayOvertime"`

	// MonthlyNightOvertime 月の深夜残業時間（分）
	MonthlyNightOvertime int `json:"monthlyNightOvertime"`

	// MonthlyOvertime 月の残業時間（分）
	MonthlyOvertime int `json:"monthlyOvertime"`

	// WeeklyGeneralHolidayNightOvertime 週の法定外休日深夜残業時間（分）
	WeeklyGeneralHolidayNightOvertime int `json:"weeklyGeneralHolidayNightOvertime"`

	// WeeklyGeneralHolidayOvertime 週の法定外休日残業時間（分）
	WeeklyGeneralHolidayOvertime int `json:"weeklyGeneralHolidayOvertime"`

	// WeeklyLegalHolidayNightOvertime 週の法定休日深夜残業時間（分）
	WeeklyLegalHolidayNightOvertime int `json:"weeklyLegalHolidayNightOvertime"`

	// WeeklyLegalHolidayOvertime 週の法定休日残業時間（分）
	WeeklyLegalHolidayOvertime int `json:"weeklyLegalHolidayOvertime"`

	// WeeklyNightOvertime 週の深夜残業時間（分）
	WeeklyNightOvertime int `json:"weeklyNightOvertime"`

	// WeeklyOvertime 週の残業時間（分）
	WeeklyOvertime int `json:"weeklyOvertime"`

	// YearlyGeneralHolidayNightOvertime 年の法定外休日深夜残業時間（分）
	YearlyGeneralHolidayNightOvertime int `json:"yearlyGeneralHolidayNightOvertime"`

	// YearlyGeneralHolidayOvertime 年の法定外休日残業時間（分）
	YearlyGeneralHolidayOvertime int `json:"yearlyGeneralHolidayOvertime"`

	// YearlyNightOvertime 年の深夜残業時間（分）
	YearlyNightOvertime int `json:"yearlyNightOvertime"`

	// YearlyOvertime 年の残業時間（分）
	YearlyOvertime int `json:"yearlyOvertime"`
}

// MonthlyWorkingWeeklyWork 週の残業時間
type MonthlyWorkingWeeklyWork struct {
	// GeneralHolidayNightOvertime 法定外休日深夜残業時間（分）
	GeneralHolidayNightOvertime int `json:"generalHolidayNightOvertime"`

	// GeneralHolidayOvertime 法定外休日残業時間（分）
	GeneralHolidayOvertime int `json:"generalHolidayOvertime"`

	// NightOvertime 深夜残業時間（分）
	NightOvertime int `json:"nightOvertime"`

	// Overtime 残業時間（分）
	Overtime int `json:"overtime"`
}

// RequestFlow defines model for request_flow.
type RequestFlow struct {
	// AdministratorKeys 管理者識別キー（管理者コードが変更されても不変）
	AdministratorKeys []string `json:"administratorKeys"`

	// Level 承認フローレベル（１～５）
	Level RequestFlowLevel `json:"level"`
}

// RequestFlowLevel 承認フローレベル（１～５）
type RequestFlowLevel int

// RequestOvertimeApplicant 申請者
type RequestOvertimeApplicant struct {
	// Key 識別キー（従業員 または 管理者）
	Key string `json:"key"`

	// Type 種別（employee： 従業員　administrator： 管理者)
	Type RequestOvertimeApplicantType `json:"type"`
}

// RequestOvertimeApplicantType 種別（employee： 従業員　administrator： 管理者)
type RequestOvertimeApplicantType string

// RequestOvertimeCurrent 現在のスケジュール
type RequestOvertimeCurrent struct {
	// End 終了時刻
	End KotDate `json:"end"`

	// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
	IsBeforeSchedule bool `json:"isBeforeSchedule"`

	// Start 開始時刻
	Start KotDate `json:"start"`
}

// RequestOvertimeRequested 申請内容
type RequestOvertimeRequested struct {
	// End 終了時刻
	End KotDate `json:"end"`

	// IsBeforeSchedule 勤務予定前の時間外申請か（true 予定前　false： 予定後）
	IsBeforeSchedule bool `json:"isBeforeSchedule"`

	// Start 開始時刻
	Start KotDate `json:"start"`
}

// RequestOvertimeResponse defines model for request_overtime_response.
type RequestOvertimeResponse struct {
	// AdminComment 管理者コメント
	AdminComment string `json:"adminComment"`

	// Applicant 申請者
	Applicant RequestOvertimeApplicant `json:"applicant"`

	// Current 現在のスケジュール
	Current RequestOvertimeCurrent `json:"current"`

	// CurrentFlow 現在の承認フローレベル（１～５）
	CurrentFlow RequestOvertimeResponseCurrentFlow `json:"currentFlow"`

	// Date 対象日
	Date openapi_types.Date `json:"date"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// Flow 承認フロー
	Flow *[]RequestFlow `json:"flow,omitempty"`

	// LastModifiedAdministratorKey 最終更新管理者識別キー
	LastModifiedAdministratorKey string `json:"lastModifiedAdministratorKey"`

	// Message 申請メッセージ
	Message string `json:"message"`

	// RequestKey 申請識別キー
	RequestKey string `json:"requestKey"`

	// Requested 申請内容
	Requested RequestOvertimeRequested `json:"requested"`

	// RequestedDate 申請日
	RequestedDate openapi_types.Date `json:"requestedDate"`

	// Status 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
	Status RequestOvertimeResponseStatus `json:"status"`
}

// RequestOvertimeResponseCurrentFlow 現在の承認フローレベル（１～５）
type RequestOvertimeResponseCurrentFlow int

// RequestOvertimeResponseStatus 申請ステータス（applying 申請中　rejected： 棄却　approved： 承認）
type RequestOvertimeResponseStatus string

// WorkingTypeResponse defines model for working_type_response.
type WorkingTypeResponse struct {
	// Code 雇用区分コード
	Code string `json:"code"`

	// Name 雇用区分名
	Name string `json:"name"`
}

// YearlyWorkingCurrentDateEmployee 今日時点の従業員データ
type YearlyWorkingCurrentDateEmployee struct {
	// Code 従業員コード
	Code string `json:"code"`

	// DivisionCode 所属コード
	DivisionCode string `json:"divisionCode"`

	// DivisionName 所属名
	DivisionName string `json:"divisionName"`

	// EmployeeGroups 従業員グループ情報
	EmployeeGroups []EmployeeGroup `json:"employeeGroups"`

	// FirstName 名
	FirstName string `json:"firstName"`

	// FirstNamePhonetics 名（カナ）
	FirstNamePhonetics string `json:"firstNamePhonetics"`

	// Gender 性別（no_selected： 選択しない　male： 男性　female： 女性）
	Gender YearlyWorkingCurrentDateEmployeeGender `json:"gender"`

	// LastName 姓
	LastName string `json:"lastName"`

	// LastNamePhonetics 姓（カナ）
	LastNamePhonetics string `json:"lastNamePhonetics"`

	// TypeCode 雇用区分コード
	TypeCode string `json:"typeCode"`

	// TypeName 雇用区分名
	TypeName string `json:"typeName"`
}

// YearlyWorkingCurrentDateEmployeeGender 性別（no_selected： 選択しない　male： 男性　female： 女性）
type YearlyWorkingCurrentDateEmployeeGender string

// YearlyWorkingEmployee defines model for yearly_working_employee.
type YearlyWorkingEmployee struct {
	// CurrentDateEmployee 今日時点の従業員データ
	CurrentDateEmployee *YearlyWorkingCurrentDateEmployee `json:"currentDateEmployee,omitempty"`

	// EmployeeKey 従業員識別キー（従業員コードが変更されても不変）
	EmployeeKey string `json:"employeeKey"`

	// Holidays 付与・取得一覧
	Holidays []YearlyWorkingEmployeeHoliday `json:"holidays"`
}

// YearlyWorkingEmployeeHoliday defines model for yearly_working_employee_holiday.
type YearlyWorkingEmployeeHoliday struct {
	// Code 休暇区分コード
	Code int `json:"code"`

	// Expired 失効一覧
	Expired []YearlyWorkingEmployeeHolidayExpired `json:"expired"`

	// Granted 付与一覧
	Granted []YearlyWorkingEmployeeHolidayGranted `json:"granted"`

	// Name 休暇区分名
	Name string `json:"name"`

	// Obtained 取得一覧
	Obtained []YearlyWorkingEmployeeHolidayObtained `json:"obtained"`

	// Remained 繰越一覧
	Remained []YearlyWorkingEmployeeHolidayRemained `json:"remained"`
}

// YearlyWorkingEmployeeHolidayExpired defines model for yearly_working_employee_holiday_expired.
type YearlyWorkingEmployeeHolidayExpired struct {
	// Date 失効日
	Date openapi_types.Date `json:"date"`

	// Days 失効日数
	Days int `json:"days"`

	// Minutes 失効時間(分)
	Minutes int `json:"minutes"`
}

// YearlyWorkingEmployeeHolidayGranted defines model for yearly_working_employee_holiday_granted.
type YearlyWorkingEmployeeHolidayGranted struct {
	// Date 付与日
	Date openapi_types.Date `json:"date"`

	// Days 付与日数
	Days int `json:"days"`

	// EffectivePeriod 有効期限
	EffectivePeriod openapi_types.Date `json:"effectivePeriod"`

	// Minutes 付与時間(分)
	Minutes int `json:"minutes"`
}

// YearlyWorkingEmployeeHolidayObtained defines model for yearly_working_employee_holiday_obtained.
type YearlyWorkingEmployeeHolidayObtained struct {
	// Date 取得日
	Date openapi_types.Date `json:"date"`

	// Days 取得日数
	Days int `json:"days"`

	// Minutes 取得時間(分)
	Minutes int `json:"minutes"`
}

// YearlyWorkingEmployeeHolidayRemained defines model for yearly_working_employee_holiday_remained.
type YearlyWorkingEmployeeHolidayRemained struct {
	// Date 繰越日
	Date openapi_types.Date `json:"date"`

	// Days 繰越日数
	Days int `json:"days"`

	// Minutes 繰越時間(分)
	Minutes int `json:"minutes"`
}

// AdditionalFieldsAdministrator defines model for additionalFields_administrator.
type AdditionalFieldsAdministrator = []string

// AdditionalFieldsDailyWorkings defines model for additionalFields_daily-workings.
type AdditionalFieldsDailyWorkings = []string

// AdditionalFieldsEmployee defines model for additionalFields_employee.
type AdditionalFieldsEmployee = []string

// AdditionalFieldsEmployeeGroups defines model for additionalFields_employee-groups.
type AdditionalFieldsEmployeeGroups = []string

// AdditionalFieldsMonthlyWorkings defines model for additionalFields_monthly-workings.
type AdditionalFieldsMonthlyWorkings = []string

// AdditionalFieldsMonthlyWorkingsCost defines model for additionalFields_monthly-workings-cost.
type AdditionalFieldsMonthlyWorkingsCost = []string

// Date defaultは当日
type Date = openapi_types.Date

// DateRequired defaultは当日
type DateRequired = openapi_types.Date

// DateYearMonthInPath defaultは当月
type DateYearMonthInPath = string

// Division defines model for division.
type Division = string

// EmployeeCode defines model for employeeCode.
type EmployeeCode = string

// EmployeeKey defines model for employeeKey.
type EmployeeKey = string

// EmployeeKeys defines model for employeeKeys.
type EmployeeKeys = []string

// EmployeeTypeCodeInPath defines model for employeeTypeCode_in_path.
type EmployeeTypeCodeInPath = int

// End defaultは当日
type End = openapi_types.Date

// IncludeResigner defines model for includeResigner.
type IncludeResigner = bool

// Ondivision defines model for ondivision.
type Ondivision = bool

// Start defaultは当日
type Start = openapi_types.Date

// Token defines model for token.
type Token = string

// UpdateDate defaultは当日
type UpdateDate = openapi_types.Date

// YearInPath defines model for year_in_path.
type YearInPath = int

// GetAdministratorsParams defines parameters for GetAdministrators.
type GetAdministratorsParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsAdministrator `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetAdministratorsParamsAdditionalFields defines parameters for GetAdministrators.
type GetAdministratorsParamsAdditionalFields string

// GetDailyWorkingsParams defines parameters for GetDailyWorkings.
type GetDailyWorkingsParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// Start 取得したい期間の開始年月日
	// ・過去日は最大3年前まで
	Start *Start `form:"start,omitempty" json:"start,omitempty"`

	// End 取得したい期間の終了年月日
	// ・startとendは同時に指定
	// ・期間は最大62日
	// ・未来日は最大1年後まで
	End *End `form:"end,omitempty" json:"end,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingsParamsAdditionalFields defines parameters for GetDailyWorkings.
type GetDailyWorkingsParamsAdditionalFields string

// GetDailyWorkingCostsParams defines parameters for GetDailyWorkingCosts.
type GetDailyWorkingCostsParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// Start 取得したい期間の開始年月日
	// ・過去日は最大3年前まで
	Start *Start `form:"start,omitempty" json:"start,omitempty"`

	// End 取得したい期間の終了年月日
	// ・startとendは同時に指定
	// ・期間は最大62日
	// ・未来日は最大1年後まで
	End *End `form:"end,omitempty" json:"end,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingCostsParamsAdditionalFields defines parameters for GetDailyWorkingCosts.
type GetDailyWorkingCostsParamsAdditionalFields string

// GetDailyWorkingCostParams defines parameters for GetDailyWorkingCost.
type GetDailyWorkingCostParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingCostParamsAdditionalFields defines parameters for GetDailyWorkingCost.
type GetDailyWorkingCostParamsAdditionalFields string

// GetDailyWorkingTimerecordsParams defines parameters for GetDailyWorkingTimerecords.
type GetDailyWorkingTimerecordsParams struct {
	// EmployeeKeys 従業員識別キー（従業員コードが変更されても不変）
	// ,区切りで複数従業員の指定可能
	// divisionが指定されていない場合のみ使用可能
	EmployeeKeys *EmployeeKeys `form:"employeeKeys,omitempty" json:"employeeKeys,omitempty"`

	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// Start 取得したい期間の開始年月日
	// ・過去日は最大3年前まで
	Start *Start `form:"start,omitempty" json:"start,omitempty"`

	// End 取得したい期間の終了年月日
	// ・startとendは同時に指定
	// ・期間は最大62日
	// ・未来日は最大1年後まで
	End *End `form:"end,omitempty" json:"end,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingTimerecordsParamsAdditionalFields defines parameters for GetDailyWorkingTimerecords.
type GetDailyWorkingTimerecordsParamsAdditionalFields string

// GetDailyWorkingTimerecordParams defines parameters for GetDailyWorkingTimerecord.
type GetDailyWorkingTimerecordParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingTimerecordParamsAdditionalFields defines parameters for GetDailyWorkingTimerecord.
type GetDailyWorkingTimerecordParamsAdditionalFields string

// GetDailyWorkingParams defines parameters for GetDailyWorking.
type GetDailyWorkingParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// Ondivision ・true:所属に基づいた勤務データ
	// ・false:出勤先に基づいた勤務データ
	// ・divisionが指定されている場合のみ使用可能
	Ondivision *Ondivision `form:"ondivision,omitempty" json:"ondivision,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsDailyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetDailyWorkingParamsAdditionalFields defines parameters for GetDailyWorking.
type GetDailyWorkingParamsAdditionalFields string

// GetEmployeeGroupsParams defines parameters for GetEmployeeGroups.
type GetEmployeeGroupsParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployeeGroups `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeeGroupsParamsAdditionalFields defines parameters for GetEmployeeGroups.
type GetEmployeeGroupsParamsAdditionalFields string

// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams struct {
	// Date 指定された年月日時点での従業員のデータを表示
	// ・過去日は最大3年前まで
	// ・未来日は最大1年後まで
	Date *Date `form:"date,omitempty" json:"date,omitempty"`

	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// IncludeResigner 指定された年月日時点で退職済みの従業員を含む場合 True
	IncludeResigner *IncludeResigner `form:"includeResigner,omitempty" json:"includeResigner,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployee `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeesParamsAdditionalFields defines parameters for GetEmployees.
type GetEmployeesParamsAdditionalFields string

// GetEmployeeParams defines parameters for GetEmployee.
type GetEmployeeParams struct {
	// Date 指定された年月日時点での従業員のデータを表示
	// ・過去日は最大3年前まで
	// ・未来日は最大1年後まで
	Date *Date `form:"date,omitempty" json:"date,omitempty"`

	// IncludeResigner 指定された年月日時点で退職済みの従業員を含む場合 True
	IncludeResigner *IncludeResigner `form:"includeResigner,omitempty" json:"includeResigner,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsEmployee `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetEmployeeParamsAdditionalFields defines parameters for GetEmployee.
type GetEmployeeParamsAdditionalFields string

// UpdateEmployeeParams defines parameters for UpdateEmployee.
type UpdateEmployeeParams struct {
	// UpdateDate 所属、雇用区分を更新したい年月日
	UpdateDate *UpdateDate `form:"updateDate,omitempty" json:"updateDate,omitempty"`
}

// GetMonthlyWorkingCostParams defines parameters for GetMonthlyWorkingCost.
type GetMonthlyWorkingCostParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsMonthlyWorkingsCost `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetMonthlyWorkingCostParamsAdditionalFields defines parameters for GetMonthlyWorkingCost.
type GetMonthlyWorkingCostParamsAdditionalFields string

// GetMonthlyWorkingHolidayRemainedParams defines parameters for GetMonthlyWorkingHolidayRemained.
type GetMonthlyWorkingHolidayRemainedParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsMonthlyWorkingsCost `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetMonthlyWorkingHolidayRemainedParamsAdditionalFields defines parameters for GetMonthlyWorkingHolidayRemained.
type GetMonthlyWorkingHolidayRemainedParamsAdditionalFields string

// GetMonthlyWorkingParams defines parameters for GetMonthlyWorking.
type GetMonthlyWorkingParams struct {
	// Division 所属コード
	Division *Division `form:"division,omitempty" json:"division,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsMonthlyWorkings `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetMonthlyWorkingParamsAdditionalFields defines parameters for GetMonthlyWorking.
type GetMonthlyWorkingParamsAdditionalFields string

// GetOvertimeParams defines parameters for GetOvertime.
type GetOvertimeParams struct {
	// AdministratorKey 管理者識別キー（管理者コードが変更されても不変）
	AdministratorKey *string `form:"administratorKey,omitempty" json:"administratorKey,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *[]GetOvertimeParamsAdditionalFields `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetOvertimeParamsAdditionalFields defines parameters for GetOvertime.
type GetOvertimeParamsAdditionalFields string

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// AdministratorKey 管理者識別キー（管理者コードが変更されても不変）
	AdministratorKey *string `form:"administratorKey,omitempty" json:"administratorKey,omitempty"`

	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *[]GetSchedulesParamsAdditionalFields `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetSchedulesParamsAdditionalFields defines parameters for GetSchedules.
type GetSchedulesParamsAdditionalFields string

// GetYearlyWorkingHolidayParams defines parameters for GetYearlyWorkingHoliday.
type GetYearlyWorkingHolidayParams struct {
	// AdditionalFields 指定されたプロパティをレスポンスに追加
	AdditionalFields *AdditionalFieldsMonthlyWorkingsCost `form:"additionalFields,omitempty" json:"additionalFields,omitempty"`
}

// GetYearlyWorkingHolidayParamsAdditionalFields defines parameters for GetYearlyWorkingHoliday.
type GetYearlyWorkingHolidayParamsAdditionalFields string

// RegisterDailyWorkingTimerecordJSONRequestBody defines body for RegisterDailyWorkingTimerecord for application/json ContentType.
type RegisterDailyWorkingTimerecordJSONRequestBody = DailyWorkingTimerecordRequest

// RegisterEmployeeJSONRequestBody defines body for RegisterEmployee for application/json ContentType.
type RegisterEmployeeJSONRequestBody = EmployeeRequest

// UpdateEmployeeJSONRequestBody defines body for UpdateEmployee for application/json ContentType.
type UpdateEmployeeJSONRequestBody = EmployeeRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAdministrators request
	GetAdministrators(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompany request
	GetCompany(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkings request
	GetDailyWorkings(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingCosts request
	GetDailyWorkingCosts(ctx context.Context, params *GetDailyWorkingCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingCost request
	GetDailyWorkingCost(ctx context.Context, date DateRequired, params *GetDailyWorkingCostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingTimerecords request
	GetDailyWorkingTimerecords(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorkingTimerecord request
	GetDailyWorkingTimerecord(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterDailyWorkingTimerecord request with any body
	RegisterDailyWorkingTimerecordWithBody(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterDailyWorkingTimerecord(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyWorking request
	GetDailyWorking(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDivisions request
	GetDivisions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployeeGroups request
	GetEmployeeGroups(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployees request
	GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterEmployee request with any body
	RegisterEmployeeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterEmployee(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployee request
	GetEmployee(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmployee request
	DeleteEmployee(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBody(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmployee(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonthlyWorkingCost request
	GetMonthlyWorkingCost(ctx context.Context, date DateYearMonthInPath, params *GetMonthlyWorkingCostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonthlyWorkingHolidayRemained request
	GetMonthlyWorkingHolidayRemained(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, date DateYearMonthInPath, params *GetMonthlyWorkingHolidayRemainedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonthlyWorking request
	GetMonthlyWorking(ctx context.Context, date DateRequired, params *GetMonthlyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOvertime request
	GetOvertime(ctx context.Context, date string, params *GetOvertimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendAccessToken request
	SuspendAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAccessToken request
	RefreshAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessTokenAvailability request
	GetAccessTokenAvailability(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkingTypes request
	GetWorkingTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetYearlyWorkingHoliday request
	GetYearlyWorkingHoliday(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, year YearInPath, params *GetYearlyWorkingHolidayParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAdministrators(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdministratorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompany(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkings(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingCosts(ctx context.Context, params *GetDailyWorkingCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingCostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingCost(ctx context.Context, date DateRequired, params *GetDailyWorkingCostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingCostRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingTimerecords(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingTimerecordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorkingTimerecord(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingTimerecordRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterDailyWorkingTimerecordWithBody(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterDailyWorkingTimerecordRequestWithBody(c.Server, employeeKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterDailyWorkingTimerecord(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterDailyWorkingTimerecordRequest(c.Server, employeeKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyWorking(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyWorkingRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDivisions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDivisionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployeeGroups(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeeGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEmployeeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEmployeeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEmployee(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEmployeeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployee(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeeRequest(c.Server, employeeCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmployee(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmployeeRequest(c.Server, employeeKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployeeWithBody(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequestWithBody(c.Server, employeeKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployee(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequest(c.Server, employeeKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonthlyWorkingCost(ctx context.Context, date DateYearMonthInPath, params *GetMonthlyWorkingCostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonthlyWorkingCostRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonthlyWorkingHolidayRemained(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, date DateYearMonthInPath, params *GetMonthlyWorkingHolidayRemainedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonthlyWorkingHolidayRemainedRequest(c.Server, employeeTypeCode, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonthlyWorking(ctx context.Context, date DateRequired, params *GetMonthlyWorkingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonthlyWorkingRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOvertime(ctx context.Context, date string, params *GetOvertimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOvertimeRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendAccessTokenRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessToken(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessTokenAvailability(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessTokenAvailabilityRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkingTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkingTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetYearlyWorkingHoliday(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, year YearInPath, params *GetYearlyWorkingHolidayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetYearlyWorkingHolidayRequest(c.Server, employeeTypeCode, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAdministratorsRequest generates requests for GetAdministrators
func NewGetAdministratorsRequest(server string, params *GetAdministratorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/administrators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyRequest generates requests for GetCompany
func NewGetCompanyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/company")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingsRequest generates requests for GetDailyWorkings
func NewGetDailyWorkingsRequest(server string, params *GetDailyWorkingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingCostsRequest generates requests for GetDailyWorkingCosts
func NewGetDailyWorkingCostsRequest(server string, params *GetDailyWorkingCostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/cost")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingCostRequest generates requests for GetDailyWorkingCost
func NewGetDailyWorkingCostRequest(server string, date DateRequired, params *GetDailyWorkingCostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/cost/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingTimerecordsRequest generates requests for GetDailyWorkingTimerecords
func NewGetDailyWorkingTimerecordsRequest(server string, params *GetDailyWorkingTimerecordsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EmployeeKeys != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "employeeKeys", runtime.ParamLocationQuery, *params.EmployeeKeys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDailyWorkingTimerecordRequest generates requests for GetDailyWorkingTimerecord
func NewGetDailyWorkingTimerecordRequest(server string, date DateRequired, params *GetDailyWorkingTimerecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterDailyWorkingTimerecordRequest calls the generic RegisterDailyWorkingTimerecord builder with application/json body
func NewRegisterDailyWorkingTimerecordRequest(server string, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterDailyWorkingTimerecordRequestWithBody(server, employeeKey, "application/json", bodyReader)
}

// NewRegisterDailyWorkingTimerecordRequestWithBody generates requests for RegisterDailyWorkingTimerecord with any type of body
func NewRegisterDailyWorkingTimerecordRequestWithBody(server string, employeeKey EmployeeKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/timerecord/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDailyWorkingRequest generates requests for GetDailyWorking
func NewGetDailyWorkingRequest(server string, date DateRequired, params *GetDailyWorkingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/daily-workings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ondivision != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ondivision", runtime.ParamLocationQuery, *params.Ondivision); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDivisionsRequest generates requests for GetDivisions
func NewGetDivisionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/divisions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeeGroupsRequest generates requests for GetEmployeeGroups
func NewGetEmployeeGroupsRequest(server string, params *GetEmployeeGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employee-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeResigner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeResigner", runtime.ParamLocationQuery, *params.IncludeResigner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterEmployeeRequest calls the generic RegisterEmployee builder with application/json body
func NewRegisterEmployeeRequest(server string, body RegisterEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterEmployeeRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterEmployeeRequestWithBody generates requests for RegisterEmployee with any type of body
func NewRegisterEmployeeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEmployeeRequest generates requests for GetEmployee
func NewGetEmployeeRequest(server string, employeeCode EmployeeCode, params *GetEmployeeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeCode", runtime.ParamLocationPath, employeeCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeResigner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeResigner", runtime.ParamLocationQuery, *params.IncludeResigner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEmployeeRequest generates requests for DeleteEmployee
func NewDeleteEmployeeRequest(server string, employeeKey EmployeeKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEmployeeRequest calls the generic UpdateEmployee builder with application/json body
func NewUpdateEmployeeRequest(server string, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmployeeRequestWithBody(server, employeeKey, params, "application/json", bodyReader)
}

// NewUpdateEmployeeRequestWithBody generates requests for UpdateEmployee with any type of body
func NewUpdateEmployeeRequestWithBody(server string, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeKey", runtime.ParamLocationPath, employeeKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateDate", runtime.ParamLocationQuery, *params.UpdateDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMonthlyWorkingCostRequest generates requests for GetMonthlyWorkingCost
func NewGetMonthlyWorkingCostRequest(server string, date DateYearMonthInPath, params *GetMonthlyWorkingCostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monthly-workings/cost/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMonthlyWorkingHolidayRemainedRequest generates requests for GetMonthlyWorkingHolidayRemained
func NewGetMonthlyWorkingHolidayRemainedRequest(server string, employeeTypeCode EmployeeTypeCodeInPath, date DateYearMonthInPath, params *GetMonthlyWorkingHolidayRemainedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeTypeCode", runtime.ParamLocationPath, employeeTypeCode)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monthly-workings/holiday-remained/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMonthlyWorkingRequest generates requests for GetMonthlyWorking
func NewGetMonthlyWorkingRequest(server string, date DateRequired, params *GetMonthlyWorkingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monthly-workings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Division != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "division", runtime.ParamLocationQuery, *params.Division); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOvertimeRequest generates requests for GetOvertime
func NewGetOvertimeRequest(server string, date string, params *GetOvertimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/overtimes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdministratorKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "administratorKey", runtime.ParamLocationQuery, *params.AdministratorKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, date string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdministratorKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "administratorKey", runtime.ParamLocationQuery, *params.AdministratorKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuspendAccessTokenRequest generates requests for SuspendAccessToken
func NewSuspendAccessTokenRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshAccessTokenRequest generates requests for RefreshAccessToken
func NewRefreshAccessTokenRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessTokenAvailabilityRequest generates requests for GetAccessTokenAvailability
func NewGetAccessTokenAvailabilityRequest(server string, token Token) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/%s/available", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkingTypesRequest generates requests for GetWorkingTypes
func NewGetWorkingTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/working-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetYearlyWorkingHolidayRequest generates requests for GetYearlyWorkingHoliday
func NewGetYearlyWorkingHolidayRequest(server string, employeeTypeCode EmployeeTypeCodeInPath, year YearInPath, params *GetYearlyWorkingHolidayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeTypeCode", runtime.ParamLocationPath, employeeTypeCode)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/yearly-workings/holidays/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "additionalFields", runtime.ParamLocationQuery, *params.AdditionalFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAdministrators request
	GetAdministratorsWithResponse(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*GetAdministratorsResponse, error)

	// GetCompany request
	GetCompanyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error)

	// GetDailyWorkings request
	GetDailyWorkingsWithResponse(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingsResponse, error)

	// GetDailyWorkingCosts request
	GetDailyWorkingCostsWithResponse(ctx context.Context, params *GetDailyWorkingCostsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingCostsResponse, error)

	// GetDailyWorkingCost request
	GetDailyWorkingCostWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingCostParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingCostResponse, error)

	// GetDailyWorkingTimerecords request
	GetDailyWorkingTimerecordsWithResponse(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordsResponse, error)

	// GetDailyWorkingTimerecord request
	GetDailyWorkingTimerecordWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordResponse, error)

	// RegisterDailyWorkingTimerecord request with any body
	RegisterDailyWorkingTimerecordWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error)

	RegisterDailyWorkingTimerecordWithResponse(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error)

	// GetDailyWorking request
	GetDailyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingResponse, error)

	// GetDivisions request
	GetDivisionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDivisionsResponse, error)

	// GetEmployeeGroups request
	GetEmployeeGroupsWithResponse(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*GetEmployeeGroupsResponse, error)

	// GetEmployees request
	GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesResponse, error)

	// RegisterEmployee request with any body
	RegisterEmployeeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error)

	RegisterEmployeeWithResponse(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error)

	// GetEmployee request
	GetEmployeeWithResponse(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error)

	// DeleteEmployee request
	DeleteEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	UpdateEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	// GetMonthlyWorkingCost request
	GetMonthlyWorkingCostWithResponse(ctx context.Context, date DateYearMonthInPath, params *GetMonthlyWorkingCostParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingCostResponse, error)

	// GetMonthlyWorkingHolidayRemained request
	GetMonthlyWorkingHolidayRemainedWithResponse(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, date DateYearMonthInPath, params *GetMonthlyWorkingHolidayRemainedParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingHolidayRemainedResponse, error)

	// GetMonthlyWorking request
	GetMonthlyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetMonthlyWorkingParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingResponse, error)

	// GetOvertime request
	GetOvertimeWithResponse(ctx context.Context, date string, params *GetOvertimeParams, reqEditors ...RequestEditorFn) (*GetOvertimeResponse, error)

	// GetSchedules request
	GetSchedulesWithResponse(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// SuspendAccessToken request
	SuspendAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*SuspendAccessTokenResponse, error)

	// RefreshAccessToken request
	RefreshAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	// GetAccessTokenAvailability request
	GetAccessTokenAvailabilityWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*GetAccessTokenAvailabilityResponse, error)

	// GetWorkingTypes request
	GetWorkingTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkingTypesResponse, error)

	// GetYearlyWorkingHoliday request
	GetYearlyWorkingHolidayWithResponse(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, year YearInPath, params *GetYearlyWorkingHolidayParams, reqEditors ...RequestEditorFn) (*GetYearlyWorkingHolidayResponse, error)
}

type GetAdministratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAdministrators
}

// Status returns HTTPResponse.Status
func (r GetAdministratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdministratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCompany
}

// Status returns HTTPResponse.Status
func (r GetCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDailyWorkings
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDailyWorkingCosts
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingCostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDailyWorkingCost
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingCostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingCostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingTimerecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDailyWorkingTimerecords
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingTimerecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingTimerecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingTimerecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DailyWorkings []DailyWorkingTimerecord `json:"dailyWorkings"`
		Date          openapi_types.Date       `json:"date"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingTimerecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingTimerecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterDailyWorkingTimerecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RegisterDailyWorkingTimerecord
}

// Status returns HTTPResponse.Status
func (r RegisterDailyWorkingTimerecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterDailyWorkingTimerecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyWorkingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDailyWorking
}

// Status returns HTTPResponse.Status
func (r GetDailyWorkingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyWorkingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDivisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDivisions
}

// Status returns HTTPResponse.Status
func (r GetDivisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDivisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEmployeeGroups
}

// Status returns HTTPResponse.Status
func (r GetEmployeeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEmployees
}

// Status returns HTTPResponse.Status
func (r GetEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RegisterEmployee
}

// Status returns HTTPResponse.Status
func (r RegisterEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEmployee
}

// Status returns HTTPResponse.Status
func (r GetEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateEmployee
}

// Status returns HTTPResponse.Status
func (r UpdateEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonthlyWorkingCostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MonthlyWorkingCostResponse
}

// Status returns HTTPResponse.Status
func (r GetMonthlyWorkingCostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonthlyWorkingCostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonthlyWorkingHolidayRemainedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMonthlyWorkingHolidayRemained
}

// Status returns HTTPResponse.Status
func (r GetMonthlyWorkingHolidayRemainedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonthlyWorkingHolidayRemainedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonthlyWorkingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMonthlyWorking
}

// Status returns HTTPResponse.Status
func (r GetMonthlyWorkingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonthlyWorkingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOvertimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOvertime
}

// Status returns HTTPResponse.Status
func (r GetOvertimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOvertimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchedules
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SuspendAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RefreshAccessToken
}

// Status returns HTTPResponse.Status
func (r RefreshAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessTokenAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokenAvailability
}

// Status returns HTTPResponse.Status
func (r GetAccessTokenAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessTokenAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkingTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkingTypeResponse
}

// Status returns HTTPResponse.Status
func (r GetWorkingTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkingTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetYearlyWorkingHolidayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetYearlyWorkingHoliday
}

// Status returns HTTPResponse.Status
func (r GetYearlyWorkingHolidayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetYearlyWorkingHolidayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAdministratorsWithResponse request returning *GetAdministratorsResponse
func (c *ClientWithResponses) GetAdministratorsWithResponse(ctx context.Context, params *GetAdministratorsParams, reqEditors ...RequestEditorFn) (*GetAdministratorsResponse, error) {
	rsp, err := c.GetAdministrators(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdministratorsResponse(rsp)
}

// GetCompanyWithResponse request returning *GetCompanyResponse
func (c *ClientWithResponses) GetCompanyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error) {
	rsp, err := c.GetCompany(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyResponse(rsp)
}

// GetDailyWorkingsWithResponse request returning *GetDailyWorkingsResponse
func (c *ClientWithResponses) GetDailyWorkingsWithResponse(ctx context.Context, params *GetDailyWorkingsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingsResponse, error) {
	rsp, err := c.GetDailyWorkings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingsResponse(rsp)
}

// GetDailyWorkingCostsWithResponse request returning *GetDailyWorkingCostsResponse
func (c *ClientWithResponses) GetDailyWorkingCostsWithResponse(ctx context.Context, params *GetDailyWorkingCostsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingCostsResponse, error) {
	rsp, err := c.GetDailyWorkingCosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingCostsResponse(rsp)
}

// GetDailyWorkingCostWithResponse request returning *GetDailyWorkingCostResponse
func (c *ClientWithResponses) GetDailyWorkingCostWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingCostParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingCostResponse, error) {
	rsp, err := c.GetDailyWorkingCost(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingCostResponse(rsp)
}

// GetDailyWorkingTimerecordsWithResponse request returning *GetDailyWorkingTimerecordsResponse
func (c *ClientWithResponses) GetDailyWorkingTimerecordsWithResponse(ctx context.Context, params *GetDailyWorkingTimerecordsParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordsResponse, error) {
	rsp, err := c.GetDailyWorkingTimerecords(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingTimerecordsResponse(rsp)
}

// GetDailyWorkingTimerecordWithResponse request returning *GetDailyWorkingTimerecordResponse
func (c *ClientWithResponses) GetDailyWorkingTimerecordWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingTimerecordParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingTimerecordResponse, error) {
	rsp, err := c.GetDailyWorkingTimerecord(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingTimerecordResponse(rsp)
}

// RegisterDailyWorkingTimerecordWithBodyWithResponse request with arbitrary body returning *RegisterDailyWorkingTimerecordResponse
func (c *ClientWithResponses) RegisterDailyWorkingTimerecordWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error) {
	rsp, err := c.RegisterDailyWorkingTimerecordWithBody(ctx, employeeKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterDailyWorkingTimerecordResponse(rsp)
}

func (c *ClientWithResponses) RegisterDailyWorkingTimerecordWithResponse(ctx context.Context, employeeKey EmployeeKey, body RegisterDailyWorkingTimerecordJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterDailyWorkingTimerecordResponse, error) {
	rsp, err := c.RegisterDailyWorkingTimerecord(ctx, employeeKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterDailyWorkingTimerecordResponse(rsp)
}

// GetDailyWorkingWithResponse request returning *GetDailyWorkingResponse
func (c *ClientWithResponses) GetDailyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetDailyWorkingParams, reqEditors ...RequestEditorFn) (*GetDailyWorkingResponse, error) {
	rsp, err := c.GetDailyWorking(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyWorkingResponse(rsp)
}

// GetDivisionsWithResponse request returning *GetDivisionsResponse
func (c *ClientWithResponses) GetDivisionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDivisionsResponse, error) {
	rsp, err := c.GetDivisions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDivisionsResponse(rsp)
}

// GetEmployeeGroupsWithResponse request returning *GetEmployeeGroupsResponse
func (c *ClientWithResponses) GetEmployeeGroupsWithResponse(ctx context.Context, params *GetEmployeeGroupsParams, reqEditors ...RequestEditorFn) (*GetEmployeeGroupsResponse, error) {
	rsp, err := c.GetEmployeeGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeeGroupsResponse(rsp)
}

// GetEmployeesWithResponse request returning *GetEmployeesResponse
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesResponse, error) {
	rsp, err := c.GetEmployees(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesResponse(rsp)
}

// RegisterEmployeeWithBodyWithResponse request with arbitrary body returning *RegisterEmployeeResponse
func (c *ClientWithResponses) RegisterEmployeeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error) {
	rsp, err := c.RegisterEmployeeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEmployeeResponse(rsp)
}

func (c *ClientWithResponses) RegisterEmployeeWithResponse(ctx context.Context, body RegisterEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEmployeeResponse, error) {
	rsp, err := c.RegisterEmployee(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEmployeeResponse(rsp)
}

// GetEmployeeWithResponse request returning *GetEmployeeResponse
func (c *ClientWithResponses) GetEmployeeWithResponse(ctx context.Context, employeeCode EmployeeCode, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error) {
	rsp, err := c.GetEmployee(ctx, employeeCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeeResponse(rsp)
}

// DeleteEmployeeWithResponse request returning *DeleteEmployeeResponse
func (c *ClientWithResponses) DeleteEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error) {
	rsp, err := c.DeleteEmployee(ctx, employeeKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmployeeResponse(rsp)
}

// UpdateEmployeeWithBodyWithResponse request with arbitrary body returning *UpdateEmployeeResponse
func (c *ClientWithResponses) UpdateEmployeeWithBodyWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployeeWithBody(ctx, employeeKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmployeeWithResponse(ctx context.Context, employeeKey EmployeeKey, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployee(ctx, employeeKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

// GetMonthlyWorkingCostWithResponse request returning *GetMonthlyWorkingCostResponse
func (c *ClientWithResponses) GetMonthlyWorkingCostWithResponse(ctx context.Context, date DateYearMonthInPath, params *GetMonthlyWorkingCostParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingCostResponse, error) {
	rsp, err := c.GetMonthlyWorkingCost(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonthlyWorkingCostResponse(rsp)
}

// GetMonthlyWorkingHolidayRemainedWithResponse request returning *GetMonthlyWorkingHolidayRemainedResponse
func (c *ClientWithResponses) GetMonthlyWorkingHolidayRemainedWithResponse(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, date DateYearMonthInPath, params *GetMonthlyWorkingHolidayRemainedParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingHolidayRemainedResponse, error) {
	rsp, err := c.GetMonthlyWorkingHolidayRemained(ctx, employeeTypeCode, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonthlyWorkingHolidayRemainedResponse(rsp)
}

// GetMonthlyWorkingWithResponse request returning *GetMonthlyWorkingResponse
func (c *ClientWithResponses) GetMonthlyWorkingWithResponse(ctx context.Context, date DateRequired, params *GetMonthlyWorkingParams, reqEditors ...RequestEditorFn) (*GetMonthlyWorkingResponse, error) {
	rsp, err := c.GetMonthlyWorking(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonthlyWorkingResponse(rsp)
}

// GetOvertimeWithResponse request returning *GetOvertimeResponse
func (c *ClientWithResponses) GetOvertimeWithResponse(ctx context.Context, date string, params *GetOvertimeParams, reqEditors ...RequestEditorFn) (*GetOvertimeResponse, error) {
	rsp, err := c.GetOvertime(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOvertimeResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, date string, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// SuspendAccessTokenWithResponse request returning *SuspendAccessTokenResponse
func (c *ClientWithResponses) SuspendAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*SuspendAccessTokenResponse, error) {
	rsp, err := c.SuspendAccessToken(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendAccessTokenResponse(rsp)
}

// RefreshAccessTokenWithResponse request returning *RefreshAccessTokenResponse
func (c *ClientWithResponses) RefreshAccessTokenWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessToken(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

// GetAccessTokenAvailabilityWithResponse request returning *GetAccessTokenAvailabilityResponse
func (c *ClientWithResponses) GetAccessTokenAvailabilityWithResponse(ctx context.Context, token Token, reqEditors ...RequestEditorFn) (*GetAccessTokenAvailabilityResponse, error) {
	rsp, err := c.GetAccessTokenAvailability(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessTokenAvailabilityResponse(rsp)
}

// GetWorkingTypesWithResponse request returning *GetWorkingTypesResponse
func (c *ClientWithResponses) GetWorkingTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkingTypesResponse, error) {
	rsp, err := c.GetWorkingTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkingTypesResponse(rsp)
}

// GetYearlyWorkingHolidayWithResponse request returning *GetYearlyWorkingHolidayResponse
func (c *ClientWithResponses) GetYearlyWorkingHolidayWithResponse(ctx context.Context, employeeTypeCode EmployeeTypeCodeInPath, year YearInPath, params *GetYearlyWorkingHolidayParams, reqEditors ...RequestEditorFn) (*GetYearlyWorkingHolidayResponse, error) {
	rsp, err := c.GetYearlyWorkingHoliday(ctx, employeeTypeCode, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetYearlyWorkingHolidayResponse(rsp)
}

// ParseGetAdministratorsResponse parses an HTTP response from a GetAdministratorsWithResponse call
func ParseGetAdministratorsResponse(rsp *http.Response) (*GetAdministratorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdministratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAdministrators
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyResponse parses an HTTP response from a GetCompanyWithResponse call
func ParseGetCompanyResponse(rsp *http.Response) (*GetCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCompany
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingsResponse parses an HTTP response from a GetDailyWorkingsWithResponse call
func ParseGetDailyWorkingsResponse(rsp *http.Response) (*GetDailyWorkingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDailyWorkings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingCostsResponse parses an HTTP response from a GetDailyWorkingCostsWithResponse call
func ParseGetDailyWorkingCostsResponse(rsp *http.Response) (*GetDailyWorkingCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDailyWorkingCosts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingCostResponse parses an HTTP response from a GetDailyWorkingCostWithResponse call
func ParseGetDailyWorkingCostResponse(rsp *http.Response) (*GetDailyWorkingCostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingCostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDailyWorkingCost
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingTimerecordsResponse parses an HTTP response from a GetDailyWorkingTimerecordsWithResponse call
func ParseGetDailyWorkingTimerecordsResponse(rsp *http.Response) (*GetDailyWorkingTimerecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingTimerecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDailyWorkingTimerecords
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingTimerecordResponse parses an HTTP response from a GetDailyWorkingTimerecordWithResponse call
func ParseGetDailyWorkingTimerecordResponse(rsp *http.Response) (*GetDailyWorkingTimerecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingTimerecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DailyWorkings []DailyWorkingTimerecord `json:"dailyWorkings"`
			Date          openapi_types.Date       `json:"date"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterDailyWorkingTimerecordResponse parses an HTTP response from a RegisterDailyWorkingTimerecordWithResponse call
func ParseRegisterDailyWorkingTimerecordResponse(rsp *http.Response) (*RegisterDailyWorkingTimerecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterDailyWorkingTimerecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RegisterDailyWorkingTimerecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetDailyWorkingResponse parses an HTTP response from a GetDailyWorkingWithResponse call
func ParseGetDailyWorkingResponse(rsp *http.Response) (*GetDailyWorkingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyWorkingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDailyWorking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDivisionsResponse parses an HTTP response from a GetDivisionsWithResponse call
func ParseGetDivisionsResponse(rsp *http.Response) (*GetDivisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDivisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDivisions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeeGroupsResponse parses an HTTP response from a GetEmployeeGroupsWithResponse call
func ParseGetEmployeeGroupsResponse(rsp *http.Response) (*GetEmployeeGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEmployeeGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeesResponse parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesResponse(rsp *http.Response) (*GetEmployeesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEmployees
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterEmployeeResponse parses an HTTP response from a RegisterEmployeeWithResponse call
func ParseRegisterEmployeeResponse(rsp *http.Response) (*RegisterEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RegisterEmployee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetEmployeeResponse parses an HTTP response from a GetEmployeeWithResponse call
func ParseGetEmployeeResponse(rsp *http.Response) (*GetEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEmployee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEmployeeResponse parses an HTTP response from a DeleteEmployeeWithResponse call
func ParseDeleteEmployeeResponse(rsp *http.Response) (*DeleteEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateEmployeeResponse parses an HTTP response from a UpdateEmployeeWithResponse call
func ParseUpdateEmployeeResponse(rsp *http.Response) (*UpdateEmployeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateEmployee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMonthlyWorkingCostResponse parses an HTTP response from a GetMonthlyWorkingCostWithResponse call
func ParseGetMonthlyWorkingCostResponse(rsp *http.Response) (*GetMonthlyWorkingCostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonthlyWorkingCostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MonthlyWorkingCostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMonthlyWorkingHolidayRemainedResponse parses an HTTP response from a GetMonthlyWorkingHolidayRemainedWithResponse call
func ParseGetMonthlyWorkingHolidayRemainedResponse(rsp *http.Response) (*GetMonthlyWorkingHolidayRemainedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonthlyWorkingHolidayRemainedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMonthlyWorkingHolidayRemained
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMonthlyWorkingResponse parses an HTTP response from a GetMonthlyWorkingWithResponse call
func ParseGetMonthlyWorkingResponse(rsp *http.Response) (*GetMonthlyWorkingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonthlyWorkingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMonthlyWorking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOvertimeResponse parses an HTTP response from a GetOvertimeWithResponse call
func ParseGetOvertimeResponse(rsp *http.Response) (*GetOvertimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOvertimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOvertime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSuspendAccessTokenResponse parses an HTTP response from a SuspendAccessTokenWithResponse call
func ParseSuspendAccessTokenResponse(rsp *http.Response) (*SuspendAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshAccessTokenResponse parses an HTTP response from a RefreshAccessTokenWithResponse call
func ParseRefreshAccessTokenResponse(rsp *http.Response) (*RefreshAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RefreshAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetAccessTokenAvailabilityResponse parses an HTTP response from a GetAccessTokenAvailabilityWithResponse call
func ParseGetAccessTokenAvailabilityResponse(rsp *http.Response) (*GetAccessTokenAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessTokenAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokenAvailability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkingTypesResponse parses an HTTP response from a GetWorkingTypesWithResponse call
func ParseGetWorkingTypesResponse(rsp *http.Response) (*GetWorkingTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkingTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkingTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetYearlyWorkingHolidayResponse parses an HTTP response from a GetYearlyWorkingHolidayWithResponse call
func ParseGetYearlyWorkingHolidayResponse(rsp *http.Response) (*GetYearlyWorkingHolidayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetYearlyWorkingHolidayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetYearlyWorkingHoliday
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nPr/AQAA//8Q4OAnOWYBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
